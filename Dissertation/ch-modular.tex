\chapter{Синтез модульных конечно-автоматных моделей}%
\label{ch:modular-synthesis}

Данная глава посвящена решению задачи синтеза модульных конечно-автоматных моделей с различными видами композиции модулей: (1)~параллельная (раздел~\ref{sec:modular-parallel-synthesis}), (2)~последовательная (раздел~\ref{sec:modular-consecutive-synthesis}) и (3)~произвольная (раздел~\ref{sec:modular-arbitrary-synthesis}).
% TODO: distributed CEGIS section
Раздел~\ref{sec:experiments-modular} содержит экспериментальное исследование, нацеленное на определение эффективности и применимости разработанных методов модульного синтеза.
% В качестве модельной системы используется система Pick-and-Place манипулятора, уже рассмотренная ранее в разделе~\ref{sec:experiments-monolith-pnp}.
% Несмотря на то, что оригинальная система фактически является монолитной, разработанные методы позволяют синтезировать распределенную модульную систему, обладающую схожим поведением.


% TODO: what is that?
% \subfile{tex/sec-composite-fb-model}

% \subfile{tex/sec-modular-parallel-synthesis}
\section{Метод синтеза модульных конечно-автоматных моделей с параллельной композицией модулей по примерам поведения}%
\label{sec:modular-parallel-synthesis}

В этом разделе рассматривается задача синтеза модульной конечно-автоматной модели с параллельной композицией модулей.
Аналогично главе~\ref{ch:automata-synthesis}, исходная задача сводится к задаче выполнимости SAT.
Полученное сведение состоит из двух компонент: (1)~определение переменных и (2)~определение ограничений.


\subsection{Сведение к SAT: переменные}%
\label{sub:modular-parallel-variables}

При параллельной композиции для описания каждого модуля~$m \in \Modules$ используются те же переменные, что и при монолитном синтезе \--- ко всем переменным добавляется верхний индекс~$(m)$.
Здесь и далее фраза \enquote{модуль~$m$} означает \enquote{модуль с номером~$m$}.
% TODO: Например, ... означает ... для модуля~$m$.
Дополнительно, объявляется переменная $\ModuleControllingOutputVariable_{z} \in \Modules$, кодирующая модуль, управляющий выходной переменной~$z \in Z$.
В данной постановке задачи рассматривается ситуация, когда каждый из модулей \enquote{управляет} своим собственным набором выходных переменных $\ModularSetOutputVariables \subset \SetOutputVariables$, причём эти наборы попарно не пересекаются.
Стоит отметить, что в общем случае эти наборы неизвестны заранее, а определяются динамически в ходе решения задачи SAT.
Возможна также ситуация, когда полное или частичное распределение переменных по модулям известно \--- в таком случае разработанный метод позволяет это учесть путём введения дополнительных ограничений на описанную переменную~$\ModuleControllingOutputVariable$.


\subsection{Сведение к SAT: ограничения}%
\label{sub:modular-parallel-constraints}

При модульном синтезе ограничения так же, как и при монолитном синтезе, делятся на две группы: (1)~ограничения, кодирующие структуру синтезируемого (модульного) автомата, (2)~ограничения, кодирующие соответствие поведения синтезируемого (модульного) автомата дереву сценариев.

Для кодирования структуры каждого модуля, входящего в состав модульного автомата, используются те же ограничения, что и при монолитном синтезе.
Дополнительно, вводятся следующие ограничения:
\begin{itemize}
    \item каждая выходная переменная $z \in \SetOutputVariables$ управляется ровно одним модулем:
    \[
        \ExactlyOne[m \in \Modules]{\ModuleControllingOutputVariable_{z} = m}
    \]

    \item каждый модуль $m \in \Modules$ управляет хотя бы одной выходной переменной:
    \[
        \AtLeastOne[z \in \SetOutputVariables]{\ModuleControllingOutputVariable_{z} = m}
    \]

    \item если выходная переменная $z \in \SetOutputVariables$ не управляется модулем~$m \in \Modules$, то алгоритмы во всех состояниях~$q \in \SetStates$ модуля~$m$ \enquote{ничего не делают} \--- переводят $\top$ в~$\top$ и $\bot$ в~$\bot$:
    \[
        (\ModuleControllingOutputVariable_{z} \neq m)
        \implies
        \bigland_{\mathclap{q \in \SetStates}}
        \Bigl[
            (\ModularStateAlgorithm_{q,z,\top} = \top)
            \land
            (\ModularStateAlgorithm_{q,z,\bot} = \bot)
        \Bigr]
    \]
\end{itemize}

В~свою очередь ограничения, кодирующие соответствие поведения синтезируемого модульного автомата дереву сценариев, отличаются от аналогичных при монолитном синтезе.
Для отображения пассивных вершин~$\SetTreeNodesPassive$ дерева сценариев используются те же ограничения, что и при монолитном синтезе.
А~при отображении активных вершин~$\SetTreeNodesActive$ дерева сценариев~$\PositiveTree$ на состояния~$\SetStates$ каждого модуля~$m \in \Modules$ необходимо дополнительно учитывать контролируемые этим модулем выходные переменные:
%
\begin{equation}
\label{eq:constraint-mapping}
\begin{split}
    \bigland_{m \in \Modules}
    \bigland_{v \in \SetTreeNodesActive}
    \bigland_{q \in Q}
    \biggl[
        (\ModularMapping_{v} = q)
        \iff
        % \implies
        \Bigl(
        (\ModularActualTransitionFunction_{q',e,u} = q)
        \land
        (\ModularStateOutputEvent_{q} = o)
        \land
        {}
        \Bigr.
    \biggr. \\
    \biggl.
        \Bigl.
        {}
        \land % from previous line
        \bigland_{\mathclap{z \in Z}}
        \bigl[
            (\ModuleControllingOutputVariable_{z} = m)
            \implies
            (\ModularStateAlgorithm_{q,z,\tov{p,z}} = \tov{v,z})
        \bigr]
        \Bigr)
    \biggr] ,
\end{split}
\end{equation}
где
$p = \tp{v}$,
$q' = \ModularMapping_{p}$,
$e = \tie{v}$,
$u = \tin{v}$,
$o = \toe{v}$.

% TODO: make modular output action?
Дополнительно, необходимо гарантировать корректность выходных событий модулей для соответствия дереву сценариев.
Для этого рассмотрим обработку модульным автоматом некоторого входного действия~$\InputAction$ из некоторой \textit{активной} вершины~$v$ дерева сценариев ($\toe{v} \neq \varepsilon$).
Каждый параллельный модуль $m \in \Modules$, входящий в состав модульного автомата, в ответ на входное действие генерирует выходное действие~$\OutputAction[(m)]$.
Возникает необходимость некоторым образом объединить эти выходные действия в одно~$\OutputAction$, которое будет являться финальной реакцией модульного автомата на исходное входное действие~$\InputAction$.
Фактически, необходимо использовать специальный функциональный блок, реализующий объединение событий и называемый \texttt{E\_MERGE} в IEC~61499.
Существует несколько способов такого объединения: (1)~синхронное \textit{rendezvous}, (2)~асинхронное \textit{rendezvous}, (3)~\textit{гибридное}.

Синхронное \textit{rendezvous} подразумевает ожидание завершения работы всех модулей, при этом корректной считается ситуация, когда выходные события всех модулей совпадают.
При формировании выходного действия~$\OutputAction$ используется общее выходное событие~$\OutputEvent$, а обновленные значения выходных переменных~$\OutputValues_{(m)}$ просто конкатенируются в $\OutputValues$, так как множества $\SetOutputVariables^{(m)}$ попарно не пересекаются.
Стоит отметить, что в этом случае ни один модуль не должен игнорировать входное действие, то есть не должен генерировать пустое событие $\OutputEvent = \varepsilon$.

\texttt{E\_MERGE} с асинхронным \textit{rendezvous} генерирует выходное действие равное входному, не ожидая завершения работы всех модулей
При этом модульный автомат, использующий такой тип объединения событий, в ответ на некоторое входное действие $\InputAction$ может реагировать несколькими выходными действиями.
Корректной считается следующая ситуация: каждый модуль генерируют либо выходное событие~$\OutputEvent$, либо пустое событие~$\varepsilon$; хотя бы один модуль генерирует непустое событие; объединение обновленных значений выходных переменных равно~$\OutputValues$.
Здесь~$\OutputAction$ \--- выходное действие, записанное в обрабатываемой активной вершине дерева сценариев.
Такая ситуация нарушает соответствие поведения модульного автомата дереву сценариев, однако может являться допустимой в реальном мире, так как последовательность выходных действий в ответ на одно входное все равно приводит систему к корректному состоянию с точки зрения значений выходных переменных.

Гибридный способ объединения событий является совокупностью синхронного и асинхронного \textit{rendezvous}.
Гибридный \texttt{E\_MERGE} генерирует ровно одно выходное событие (\enquote{асинхронное} поведение), при этом непустых входных событий может быть несколько, и все они учитываются для генерации совместного события.
Это достигается тем, что гибридный блок ожидает завершения работы всех модулей (\enquote{синхронное} поведение) лишь некоторое ограниченное время.
При этом считается, что все неответившие модули игнорировали входное действие, а значит, продуцировали пустое выходное событие~$\varepsilon$.
Корректной считается ситуация, когда каждый модуль генерируют либо выходное событие~$\OutputEvent$, либо пустое событие~$\varepsilon$, а объединение обновленных значений выходных переменных равно~$\OutputValues$, где $\OutputAction$ \=== выходное действие, записанное в обрабатываемой активной вершине дерева сценариев.

В приведенном выше ограничении (\ref{eq:constraint-mapping}), кодирующем отображение активных вершин дерева на состояния модулей, используется синхронный вариант объединения выходных событий.
% TODO: Потому что...


\subsection{Алгоритмы \AlgoModularParallelBasic\ и \AlgoModularParallelExtended}%
\label{sub:algorithm-modular-parallel-basic-and-extended}

Обозначим $\AlgoModularParallelBasicFull(\SetPositiveScenarios, M, C, T)$ алгоритм, реализующий синтез модели, удовлетворяющей заданным сценариям выполнения $\SetPositiveScenarios$ и состоящей из $M$ \textit{параллельно} соединенных модулей, каждый из которых состоит из $C$ состояний (то есть суммарное число состояний равно ${M \cdot C}$), а суммарное число переходов во всех модулях не больше~$T$.
Также введём обозначение для случая, когда число переходов в автомате остается неограниченным:
\[
    \AlgoModularParallelBasic(\SetPositiveScenarios, M, C) = \AlgoModularParallelBasicFull(\SetPositiveScenarios, M, C, {T = \infty})
\]

Отметим, что модификации сведения для синтеза расширенных моделей не отличаются от описанных в главе~\ref{ch:automata-synthesis} \--- структура охранных условий кодируется независимо от количества модулей и их композиции.
Поэтому здесь и далее алгоритмы, реализующие синтез расширенных моделей, будут объявляться без пояснений:
% $\AlgoModularParallelExtendedFull(\SetPositiveScenarios, M, C, P, N)$, а также отдельное обозначение:
\begin{align*}
    & \AlgoModularParallelExtended(\SetPositiveScenarios, M, C, P) = \\
    & = \AlgoModularParallelExtendedFull(\SetPositiveScenarios, M, C, P, {N = \infty})
\end{align*}


% \subfile{tex/sec-modular-consecutive-synthesis}
\section{Метод синтеза конечно-автоматной модели модульного логического контроллера с последовательной композицией модулей по примерам поведения}%
\label{sec:modular-consecutive-synthesis}

Последовательная композиция модулей значительно отличается от параллельной, так как модули в таком случае перестают быть независимыми \--- каждый следующий модуль зависит от предыдущего.
В данной работе рассматривалась постановка задачи синтеза модульного контроллера со следующими особенностями и допущениями: (1)~каждый модуль зависит от всех входных переменных \textit{внешнего} (модульного) автомата, (2)~значения выходных переменных каждого модуля зависят от предыдущих значений выходных переменных предыдущего модуля (для первого модуля \enquote{предыдущим} считается он сам), (3)~входное событие обрабатывается (то есть происходит генерация ответного выходного события) только последним модулем, до которого оно неизменно передается от модуля к модулю.
% TODO: картинка


\subsection{Сведение к SAT: переменные}%
\label{sub:modular-consecutive-variables}

Аналогично параллельной композиции, структура каждого модуля кодируется так же, как и при монолитном синтезе, с учетом допущения о том, что только последний модуль реагирует на входные события, а все предыдущие модули просто неизменно передают полученное входное событие далее \--- это достигается тем, что множества выходных событий каждого модуля приравниваются множеству входных событий:
\[
    \forall m \in [1..(M-1)] : {\ModularSetOutputEvents = \SetInputEvents} %.
\]
Дополнительно, объявляется переменная~$\ModularComputedValue_{v,z} \in \Bool$, кодирующая \enquote{вычисленное} значение выходной переменной~$z \in \SetOutputVariables$ при отображении каждой вершины~$v \in \SetTreeNodes$ дерева сценариев, то есть значение в каждый момент времени после обработки соответствующей вершины дерева.


\subsection{Сведение к SAT: ограничения}%
\label{sub:modular-consecutive-constraints}

Для определения переменной $\ModularComputedValue$ объявляются следующие ограничения.
Изначально, в момент времени после \enquote{обработки} фиктивного корня~$\TreeRoot$ дерева сценариев, вычисленные значения всех выходных переменных~$z \in \SetOutputVariables$ во всех модулях~$m \in \Modules$ равны \texttt{False}:
\[
    \bigland_{m \in \Modules}
    \bigland_{z \in \SetOutputVariables}
    (\ModularComputedValue_{\TreeRoot,z} = \bot) %.
\]
В следующие моменты времени, при обработке вершин $v \in \SetTreeNodes \setminus \{ \TreeRoot \}$, вычисляемые значения выходных переменных определяются в соответствии с работой алгоритмов в состояниях, в которых в эти моменты времени находятся модули \--- то есть в состояниях, в которые отображаются рассматриваемые вершины дерева сценариев:~$\ModularMapping_{v}$.
Для первого модуля:
\[
    \bigland_{v \in \SetTreeNodes \setminus \{ \TreeRoot \}}
    \bigland_{z \in \SetOutputVariables}
    \Bigl[
        \ModularComputedValue_{v,z}
        \iff
        \ModularStateAlgorithm_{\ModularMapping_{v},z,\tov{\tp{v},z}}
    \Bigr] %.
\]
Для последующих модулей:
\[
    \bigland_{m \in [2 \twodots M]}
    \bigland_{v \in \SetTreeNodes \setminus \Set{\TreeRoot}}
    \bigland_{z \in \SetOutputVariables}
    \Bigl[
        \ModularComputedValue_{v,z}
        \iff
        \ModularStateAlgorithm_{\ModularMapping_{v},z,\ModularComputedValue[m-1]_{v,z}}
    \Bigr] %.
\]

При отображении активных вершин дерева необходимо учесть, что все модули, кроме последнего, передают входное событие следующему модулю. Стоит отметить, что при этом реакция модулей на входные события не изменяется \--- входные события так же играют свою роль в охранных условиях на переходах автомата.
Также необходимо учесть, что значения выходных переменных ограничиваются для соответствия дереву сценариев только для последнего модуля \--- все предыдущие модули могут производить произвольные операции над выходными переменными в рамках существующего сведения.
\begin{gather*}
    \bigland_{v \in \SetTreeNodesActive}
    \bigland_{m \in [1..(M-1)]}
    \bigland_{q \in Q}
    \Bigl[
        (\ModularMapping_{v} = q)
        \implies
        \bigl(
            (\ModularActualTransitionFunction_{q',e,u} = q)
            \land
            % Note: "outputevent = e", THIS IS NOT A TYPO
            (\ModularStateOutputEvent_{q} = e)
        \bigr)
    \Bigr] , \\
    \bigland_{v \in \SetTreeNodesActive}
    \bigland_{q \in Q}
    \Bigl[
        (\ModularMapping[M]_{v} = q)
        \implies
        \bigl(
            (\ModularActualTransitionFunction[M]_{q',e,u} = q)
            \land
            (\ModularStateOutputEvent[M]_{q} = o)
            \land
            \bigland_{\mathclap{z \in \SetOutputVariables}}
            (\ModularComputedValue[M]_{v,z} = \tov{v,z})
        \bigr)
    \Bigr] ,
\end{gather*}
где
$p = \tp{v}$,
$q' = \ModularMapping_{p}$,
$e = \tie{v}$,
$u = \tin{v}$.

При отображения пассивных вершин достаточно закодировать тот факт, что все модули игнорируют входное воздействие, то есть автоматы не изменяют своего состояния:
\[
    \bigland_{v \in \SetTreeNodesPassive}
    \bigland_{m \in \Modules}
    % TODO: check whether "= q_0" is correct, originally was "= 0"
    (\ModularActualTransitionFunction_{q',e,u} = q_0) ,
\]
где
$p = \tp{v}$,
$q' = \ModularMapping_{p}$,
$e = \tie{v}$,
$u = \tin{v}$.


\subsection{Алгоритмы \AlgoModularConsecutiveBasic\ и \AlgoModularConsecutiveExtended}%
\label{sub:algorithm-modular-consecutive-basic-and-extended}

Аналогично разделу~\ref{sub:algorithm-modular-parallel-basic-and-extended}, обозначим $\AlgoModularConsecutiveBasicFull(\SetPositiveScenarios, M, C, T)$ алгоритм, реализующий синтез модульной модели с \textit{последовательной} композицией модулей.
Также введём обозначение для случая, когда число переходов в автомате остается неограниченным:
\begin{align*}
    & \AlgoModularConsecutiveBasic(\SetPositiveScenarios, M, C) = \\
    & = \AlgoModularConsecutiveBasicFull(\SetPositiveScenarios, M, C, {T = \infty}) %.
\end{align*}
В соответствии с разделом~\ref{sub:algorithm-modular-parallel-basic-and-extended}, алгоритм для синтеза расширенных моделей объявляется без пояснений:
\begin{align*}
    & \AlgoModularConsecutiveExtended(\SetPositiveScenarios, M, C, P) = \\
    & = \AlgoModularConsecutiveExtendedFull(\SetPositiveScenarios, M, C, P, {N = \infty}) %.
\end{align*}


\section{Метод синтеза модульных конечно-автоматных моделей с произвольной композицией модулей по примерам поведения}%
\label{sec:modular-arbitrary-synthesis}

Наиболее общей формулировкой задачи синтеза конечно-автоматных моделей логических контроллеров является модульный синтез с произвольной композицией модулей.
Каждый модуль рассматривается как черный ящик с набором входных и выходных контактов для входных/выходных событий/переменных. Содержимое черного ящика \--- монолитный контроллер, структура которого кодируется так же, как при монолитном синтезе.
Совокупность модулей является внутренним содержимым модульного контроллера, так же обладающего входными и выходными \textit{контактами}.
Контакты соединяются \textit{связями}, что обеспечивает взаимодействие модулей друг с другом.
При такой постановке задачи, разрабатываемый метод обладает максимальными возможностями для синтеза комплексных модульных структур, и является свободным от ограничений, присущих рассмотренным ранее параллельной и последовательной композициям.
Стоит отметить, что для корректных вычислений выходных событий и значений выходных переменных необходимо знать порядок вычисления модулей, что возможно только если граф связей модулей является ацикличным.
Данное ограничение не уменьшает вычислительной способности модульного контроллера, поэтому в данной работе предполагается, что граф связей модулей является ацикличным, а также то, что модули упорядочены в порядке их номеров: от~1 до~$M$.

% \begin{figure}
%     % \includegraphics[max width=0.9\textwidth]{img/modular.png}
%     \includegraphics[max width=0.9\textwidth]{img/modular_full.png}
%     \caption{Пример модульного автомата с произвольной композицией}%
%     % \label{fig:my_label}
% \end{figure}


\subsection{Сведение к SAT: переменные}%
\label{sub:modular-arbitrary-variables}

Рассмотрим подробнее, как устроено сведение для модульного синтеза с произвольной композицией.
Обозначим $\ModularSetInboundVarPins = \{ {(m-1) \cdot \card{\SetInputVariables} + 1}, \dots, {m \cdot \card{\SetInputVariables}} \}$ множество входных контактов для переменных, считая, что контакты нумеруются натуральными числами, начиная с единицы, а нумерация является сквозной среди всех модулей~$m \in \Modules$ для всех контактов одного типа.
Аналогично, обозначим~$\ModularSetOutboundVarPins$ множество выходных контактов для переменных, а также обозначим множества входных и выходных контактов для событий $\ModularSetInboundEventPins$ и~$\ModularSetOutboundEventPins$.
Дополнительно, обозначим множества контактов для внешнего (модульного) автомата следующим образом: $\SetExternalInboundVarPins$, $\SetExternalOutboundVarPins$, $\SetExternalInboundEventPins$,~$\SetExternalOutboundEventPins$.
Отметим, что, например, множество~$\SetExternalInboundVarPins$ внешних входных контактов для переменных соответствует выходным переменным~$\SetOutputVariables$, так как эти контакты являются входами для входящих в них связей из выходных контактов.
При этом нумерация внешних контактов продолжает нумерацию модульных того же типа, например, $\SetExternalInboundVarPins = \{ {M \cdot \card{\SetInputVariables} + 1}, \dots, {M \cdot \card{\SetInputVariables} + \card{\SetOutputVariables}} \}$.
Для упрощения используемой нотации обозначим множества \emph{всех} входных/выходных контактов для переменных/событий $\SetInboundVarPins$, $\SetOutboundVarPins$, $\SetInboundEventPins$,~$\SetOutboundEventPins$, где, например, $\SetInboundVarPins = \bigunionnolim_{m \in \Modules} \ModularSetInboundVarPins \union \SetExternalInboundVarPins$.

Следующий шаг \--- определение графа соединений контактов модулей.
Введём переменные $\VarPinParent_{p} \in \SetOutboundVarPins$ и $\EventPinParent_{p} \in \SetOutboundEventPins$, обозначающие родителя входного контакта~$p$ для переменных/событий.
Можно заметить, что родителем входного контакта может быть только выходной контакт.
Если контакт является родителем другого, то они соединены \textit{связью}, и обновление значения родителя приводит к обновлению значения ребенка.
Пользуясь допущением об ацикличности графа соединений модулей, определим, что родителем входного контакта~$p$ может быть выходной контакт из модуля с меньшим номером, либо внешний выходной контакт, например, для некоторого контакта~$p \in \SetInboundVarPins$ из модуля~$m$:
\[
    \VarPinParent_{p} \in \SetExternalOutboundVarPins \union \bigunion_{\mathclap{m' < m}} \ModularSetOutboundVarPins[m'] %.
\]

Для каждого контакта необходимо кодировать его вычисленное значение в каждый момент времени в процессе отображения вершин дерева сценариев на состояния модулей.
Для этого вводятся переменные $\InboundVarPinComputedValue_{v,p'}$ и~$\OutboundVarPinComputedValue_{v,p''}$, кодирующие значения входных и выходных контактов ${p' \in \SetInboundVarPins}$ и ${p'' \in \SetOutboundVarPins}$ в момент времени после обработки вершины~$v$ дерева сценариев.

Важно отметить, что в отличие от рассмотренных ранее методов, при произвольной композиции каждый модуль может получать на вход произвольные наборы значений входных переменных.
Всего существует $2^{\card{\SetInputVariables}}$ таких наборов, и каждый из них должен быть корректно обработан каждым модулем.
Поэтому при кодировании структуры автомата необходимо учитывать множество всех возможных различных входов $\SetAllInputs = \boolvec{\SetInputVariables} = \{ \Vector{0 \dots 0}, \dots, \Vector{1 \dots 1} \}$, а не только множество входов $\SetTreeInputs \subseteq \SetAllInputs$, встречающихся в дереве сценариев.
Введём переменную~$\ModularInputIndex_{v} \in \SetAllInputs$, обозначающую вход в момент времени после обработки вершины~$v$ дерева сценариев.
Заметим, что вычисленные значения~$\InboundVarPinComputedValue_{v,p}$ входных контактов являются битами в бинарной записи номера входа~$u \in \SetAllInputs$, учитывая, что входы нумеруются с нуля.
Для взаимосвязи этих двух переменных была использована техника кодирования целочисленных SAT переменных OneHot+Binary~\cite{sat-encodings}: числовое значение переменной~$\ModularInputIndex_{v}$ соответствует номеру входа~$u \in \SetAllInputs$, а биты соответствующего двоичного числа \--- значениям переменной~$\InboundVarPinComputedValue_{v,p}$.


\subsection{Сведение к SAT: ограничения}%
\label{sub:modular-arbitrary-constraints}

Для определения переменных $\InboundVarPinComputedValue_{v,p}$ и $\OutboundVarPinComputedValue_{v,p}$ объявляются следующие ограничения:
\begin{enumerate}
% DC: СТОИТ НАПИСАТЬ СЛОВАМИ, КАКАЯ ИМЕННО
\item Взаимосвязь родителя контакта с его потомком:
\[
    \bigland_{v \in \SetTreeNodes}
    \bigland_{p \in \SetInboundVarPins}
    \Bigl[
        \OutboundVarPinComputedValue_{v,p}
        \iff
        \InboundVarPinComputedValue_{v,\VarPinParent_{p}}
    \Bigr]
\]

\item Начальные значения всех выходных контактов равны \texttt{False}:
\[
    \bigland_{p \in \SetOutboundVarPins}
    (\OutboundVarPinComputedValue_{1,p} = \bot)
\]

\item Значения входных переменных, записанные в вершинах дерева (кроме корня):
\[
    \bigland_{v \in \SetTreeNodes \setminus \Set{\TreeRoot}}
    \bigland_{p \in \SetExternalOutboundVarPins}
    (\OutboundVarPinComputedValue_{v,p} = \tiv{v,\funcname{pinToInputVar}(p)}) ,
\]
где $\funcname{pinToInputVar} \colon \SetExternalOutboundVarPins \to \SetInputVariables$ \--- функция, возвращающая входную переменную $x \in \SetInputVariables$, соответствующую внешнему выходному контакту $p \in \SetExternalOutboundVarPins$.

\item Значения входных контактов, у которых нет родителей, принимаются равными \texttt{False}:
\[
    \bigland_{p \in \SetInboundVarPins}
    \Bigl[
        (\VarPinParent_{p} = 0)
        \implies
        \bigland_{v \in \SetTreeNodes}
        (\InboundVarPinComputedValue_{v,p} = \bot)
    \Bigr] %.
\]
\end{enumerate}

При отображении активных вершин дерева сценариев на состояния модулей необходимо учитывать новую переменную~$\ModularInputIndex$:
\[
    \bigland_{m \in \Modules}
    \bigland_{v \in \SetTreeNodes}
    \Bigl[
        (\ModularMapping_{v} = q)
        \implies
        (\ModularActualTransitionFunction_{q',u} = q)
    \Bigr] ,
\]
где $p = \tp{v}$, $q' = \ModularMapping_{p}$, $u = \ModularInputIndex_{v}$.

Вычисляемые значения выходных контактов модулей зависят от своих предыдущих значений и определяются с помощью алгоритмов в состояниях модулей:
\[
    \bigland_{m \in \Modules}
    \bigland_{v \in \SetTreeNodes}
    \bigland_{p \in \SetOutboundVarPins}
    \bigland_{z \in \SetOutputVariables}
    \Bigl[
        \OutboundVarPinComputedValue_{v,p}
        \iff
        \fun{ITE}(\OutboundVarPinComputedValue_{v',p}, \ModularStateAlgorithm_{q,z,\top}, \ModularStateAlgorithm_{q,z,\bot})
    \Bigr] ,
\]
где $v' = \tp{v}$, $q = \ModularMapping_{v}$.
Также необходимо ограничить значения внешних входных контактов (напомним, что эти контакты соответствуют выходным переменным внешнего модульного автомата) в соответствии со значениями в дереве сценариев:
\[
    \bigland_{v \in \SetTreeNodes}
    \bigland_{p \in \SetExternalInboundVarPins}
    \Bigl[
        \InboundVarPinComputedValue_{v,p} = \tov{v, \funcname{pinToOutputVar}(p)}
    \Bigr] ,
\]
где $\funcname{pinToOutputVar}(p) \colon \SetExternalInboundVarPins \to \SetOutputVariables$ \--- функция, возвращающая выходную переменную~$z \in \SetOutputVariables$, соответствующую внешнему входному контакту~$p \in \SetExternalInboundVarPins$.

% DC: Кстати, в общем случае это, вероятно, не так. Некоторые модули могут что-то делать. Нам достаточно потребовать, что на выход не передается события, а переменные не изменяют своих значений. Можно также упомянуть про это и указать, что мы сейчас используем такое упрощение.
При отображении пассивных вершин достаточно закодировать тот факт, что все модули игнорируют входное действие, записанное в вершине дерева сценариев. При этом необходимо учесть нововведенную переменную~$\ModularInputIndex$:
\[
    \bigland_{m \in \Modules}
    \bigland_{v \in \SetTreeNodesPassive}
    \Bigl[
        (\ModularMapping_{v} = \ModularMapping_{\tp{v}})
        \land
        (\ModularActualTransitionFunction_{q',u} = 0)
    \Bigr] ,
\]
где $q' = \ModularMapping_{\tp{v}}$, $u = \ModularInputIndex_{v}$.
Также, значения выходных контактов не изменяются, так как модули не генерируют выходных событий:
\[
    \bigland_{v \in \SetTreeNodesPassive}
    \bigland_{p \in \SetOutboundVarPins}
    (\OutboundVarPinComputedValue_{v,p} = \OutboundVarPinComputedValue_{\tp{v},p})
    %.
\]


\subsection{Алгоритмы \AlgoModularArbitraryBasic\ и \AlgoModularArbitraryExtended}%
\label{sub:algorithm-modular-arbitrary-basic-and-extended}

Аналогично разделу~\ref{sub:algorithm-modular-parallel-basic-and-extended}, обозначим $\AlgoModularArbitraryBasicFull(\SetPositiveScenarios, M, C, T)$ алгоритм, реализующий синтез модульной модели с \textit{произвольной} композицией модулей.
Также введём обозначение для случая, когда число переходов в автомате остается неограниченным:
\begin{align*}
    & \AlgoModularArbitraryBasic(\SetPositiveScenarios, M, C) = \\
    & = \AlgoModularArbitraryBasicFull(\SetPositiveScenarios, M, C, {T = \infty}) %.
\end{align*}
В соответствии с разделом~\ref{sub:algorithm-modular-parallel-basic-and-extended}, алгоритм для синтеза расширенных моделей объявляется без пояснений:
\begin{align*}
    & \AlgoModularArbitraryExtended(\SetPositiveScenarios, M, C, P) = \\
    & = \AlgoModularArbitraryExtendedFull(\SetPositiveScenarios, M, C, P, {N = \infty})
\end{align*}


% \subfile{tex/sec-modular-minimal}
\section{Синтез минимальных модульных моделей}%
\label{sec:modular-minimal}

% В этом разделе рассматривается итеративный подход к синтезу минимальных модульных моделей, аналогичный рассмотренному в разделе~\ref{sec:monolith-minimal}.

Для синтеза \emph{минимальных} модульных моделей в данной работе используется тот же итеративный подход, что и при монолитном синтезе (раздел~\ref{sec:monolith-minimal}).

Алгоритм $\AlgoModularParallelBasicMin(\SetPositiveScenarios, M)$ позволяет синтезировать базовую конечно-автоматную модель композитного функционального блока с параллельной композицией заданного числа модулей~$M$ с минимальным числом состояний и переходов.
При минимизации предполагается, что все модули имеют одинаковое число состояний, а число переходов считается суммарно во всех модулях.
Возможно также рассмотрение такой постановки задачи, когда размеры каждого модуля заданы явно (или в виде некоторых интервальных оценок), однако в общем случае эти значения абсолютно неизвестны заранее.
В результате минимальная модульная модель содержит~${M \cdot \Cmin}$ состояний (по~$\Cmin$ в каждом модуле) и $\Tmin = \Tmin^{(1)} + \dotsb + \Tmin^{(M)}$ переходов.
Здесь стоит отметить, что используемая нотация~$\Tmin^{(m)}$ обозначает \textit{возможно неминимальное} число переходов в модуле~${m \in \Modules}$, входящего в состав \textit{минимальной} модульной модели с \textit{минимальным} суммарным числом переходов~$\Tmin$.

Аналогично, алгоритм $\AlgoModularParallelExtendedMin(\SetPositiveScenarios, M, P)$ позволяет синтезировать расширенную модульную модель с параллельной композицией $M$~модулей с минимальным числом состояний~${M \cdot \Cmin}$, минимальным суммарным размером охранных условий~$\Nmin$ и максимальным размером каждого охранного условия~$P$.

Аналогичным образом определяются алгоритмы для синтеза базовых и расширенных модульных моделей с последовательной и произвольной композиций модулей:
\begin{itemize}[nosep]
    \item $\AlgoModularConsecutiveBasicMin(\SetPositiveScenarios, M)$: базовая/последовательная;
    \item $\AlgoModularConsecutiveExtendedMin(\SetPositiveScenarios, M, P)$: расширенная/последовательная;
    \item $\AlgoModularArbitraryBasicMin(\SetPositiveScenarios, M)$: базовая/произвольная;
    \item $\AlgoModularArbitraryExtendedMin(\SetPositiveScenarios, M, P)$: расширенная/произвольная.
\end{itemize}



% \section{From Monolithic to Distributed Synthesis}%
% \label{sec:distributed}

% This paper proposes an extension of the \com{fbSAT} approach~\cite{fbSAT-arXiv} described in the previous section.
% The proposed extension allows for synthesis of distributed controllers, and is based on two ideas.
% The first one is to declare a reduction for monolithic case for each module independently.
% This is described in \cref{sec:distributed:modular}.
% The second idea has to do with the adaptation of CEGIS developed in~\cite{fbSAT-arXiv} to make it applicable for distributed synthesis, and is the main idea of the paper.
% % The most important difference from the monolithic case arises in the implementation of CEGIS\@.
% The difficulty of using CEGIS for distributed synthesis is that since the specification is written for the system as a whole, negative scenarios derived from counterexamples are also written for the system as a whole.
% % \commentDC{The previous sentence is imperfect, too. We should directly emphasize that since the specification is written for the distributed system as a whole, counterexamples generated by the model checker are also in terms of the system as a whole. And the question is how to deal with these counterexamples.}
% \Cref{sec:distributed:construction} describes the structure of these scenarios.
% The difficulty is that it is not known in advance, which modules behave incorrectly in some particular negative scenario, and thus we do not know, in which module do we need to prohibit the negative scenario.

% The na\"ive approach would be to prohibit each negative scenario for all modules, but it would be incorrect to do so: a behavior that is incorrect for one of the modules may be completely normal for another one.
% Thus, this na\"ive approach would lead to unsatisfiability of corresponding Boolean formulas, and the sought distributed controller would not be synthesized.

% The key idea to cope with this difficulty is to make sure that each negative scenario is prohibited for at least one module.
% This is described in \cref{sec:distributed:mapping}.
% Finally, in \cref{sec:distributed:minimal} we discuss the algorithm for minimization of inferred automata in terms of their parameters, \eg number of states and total size of guard conditions.


\section{От монолитного к распределённому синтезу}
\label{sec:distributed}

% TODO: REFORMULATE
% В данной работе предлагается расширение подхода, описанного в разделе .
Предлагаемое расширение позволяет осуществлять синтез моделей распределённых систем и основывается на двух идеях.
Первая идея заключается в том, чтобы для каждого модуля в распределённой системе независимо кодировать задачу монолитного синтеза в SAT.
Это описано в разделе~\ref{sec:distributed:modular}.
Вторая идея связана с адаптацией подхода CEGIS, описанного и использованного в разделе~\ref{sec:monolith-cegis}, с целью сделать его применимым для распределённого синтеза.

Сложность использования CEGIS для распределённого синтеза заключается в том, что поскольку спецификация написана для системы \emph{в целом}, негативные сценарии, полученные из контрпримеров, также описывают (негативное) поведение системы в целом.
Раздел~\ref{sec:distributed:construction} описывает структуру этих сценариев.
Проблема заключается в том, что заранее неизвестно, какие именно модули ведут себя неправильно в конкретном негативном сценарии, и, следовательно, неизвестно, в каком модуле необходимо запретить данный негативный сценарий.

Наивный подход заключался бы в том, чтобы запретить каждый негативный сценарий для всех модулей, но это было бы некорректно: поведение, которое является неправильным для одного из модулей, может быть совершенно нормальным для другого.
Таким образом, этот наивный подход привёл бы к невыполнимости соответствующих булевых формул, и искомая распределённая система не была бы синтезирована.

Ключевая идея для преодоления этой проблемы заключается в том, чтобы убедиться, что каждый негативный сценарий запрещён хотя бы для одного модуля.
Это описано в разделе~\ref{sec:distributed:mapping}.
Наконец, в разделе~\ref{sec:distributed:minimal} обсуждается алгоритм синтеза минимальных автоматов с точки зрения их параметров, например, количества состояний и суммарного размера охранных условий.


% \subsection{Reduction for distributed synthesis from positive scenarios}%
% \label{sec:distributed:modular}

% We declare the reduction described in \cref{sec:monolithic} for each module independently, adding the module index to every variable.
% Thus, respective constraints remain the same, but are now quantified over all modules.
% For instance, variable \(\ModularTransitionDestination_{q,k} \in \SetStatesAux\) denotes the destination state of the~$k$-th transition from state~$q$ in the automaton for the~$m$-th module, and variable \(\ModularTransitionInputEvent_{q,k} \in \SetInputEvents \union \{\varepsilon\}\) denotes the input event associated with that transition.
% With the constraint \(
%     (\ModularTransitionDestination_{q,k} = q_0) \iff (\ModularTransitionInputEvent_{q,k} = \varepsilon)
% \) we enforce that only transitions to $q_0$ are marked with the $\varepsilon$ input event.
% We also add module indices to the reduction parameters. For example, $\ModularC$ denotes the number of states in $\ModularAutomaton$ \--- the automaton for the~$m$-th module.
% All other parts of the encoding from \cref{sec:monolithic} are extended in a similar way, except for the negative mapping, which we discuss below.

% The difference with positive scenarios is that now we have a set of positive scenario trees $\Set{\ModularPositiveTree}_{m \in \Modules}$, one for each module of the distributed controller.
% % , where $\ModularPositiveTree$ is a positive scenario tree for the $m$-th module.
% Variable $\ModularMapping_{v}$ denotes a state in which the automaton for the $m$-th module finishes processing a sequence of inputs formed by following the positive tree from the root till the node~$v$ (since the tree is deterministic, for each node $v$ there is only one path from the root).
% This variable represents a mapping $\ModularMapping_{} : \ModularSetTreeNodes \to \ModularSetStates$ between the nodes of $\ModularPositiveTree$ and the states of an automaton $\ModularAutomaton$, and the constraints on this mapping are the same to those described in \cref{sec:monolithic:positive}.


\subsection{Сведение к SAT для распределённого синтеза по примерам поведения}
\label{sec:distributed:modular}

В данном подразделе представлено сведение к SAT, основа которого уже была описана в разделе~\ref{sec:monolithic}.
Для каждого модуля независимо объявляется описанный набор переменных и ограничений \--- ко всем переменным в сведении добавляется индекс модуля.
Таким образом, соответствующие ограничения остаются теми же, но теперь они также квантифицированы по всем модулям.
Например, переменная $\ModularTransitionDestination_{q,k} \in \SetStatesAux$ обозначает конечное состояние $k$-го перехода из состояния~$q$ в автомате для $m$-го модуля, а переменная $\ModularTransitionInputEvent_{q,k} \in \SetInputEvents \union \{\varepsilon\}$ обозначает входное событие, связанное с этим переходом.
Ограничение
\[
    (\ModularTransitionDestination_{q,k} = q_0)
    \iff
    (\ModularTransitionInputEvent_{q,k} = \varepsilon)
\]
обеспечивает, что только переходы в~$q_0$ отмечены входным событием~$\varepsilon$.
Мы также добавляем индексы модулей к параметрам редукции.
Например, $\ModularC$~обозначает количество состояний в~$\ModularAutomaton$ \--- автомате для $m$-го модуля.
Все остальные части кодировки из раздела~\ref{sec:monolith-synthesis} расширяются аналогичным образом, за исключением негативного отображения, которое будет разобрано ниже.

Различие с позитивными сценариями заключается в том, что теперь у нас есть \emph{набор} деревьев позитивных сценариев $\Set{\ModularPositiveTree}_{m \in \Modules}$, по одному для каждого модуля распределённой системы.
Переменная~$\ModularMapping_{v} \in \ModularSetStates$ обозначает состояние, в~котором автомат для $m$-го модуля завершает обработку последовательности входных данных, образованной следованием по положительному дереву от корня до вершины~$v$ (поскольку дерево детерминированное, для каждой вершины~$v$ существует только один путь от корня).
Эта переменная представляет отображение $\ModularMapping \colon \ModularSetTreeNodes \to \ModularSetStates$ между вершинами дерева~$\ModularPositiveTree$ и состояниями автомата~$\ModularAutomaton$, а ограничения на это отображение аналогичны описанным в разделе~\ref{sub:encoding-positive-mapping}.


% \subsection{Compound Negative Scenario Tree}%
% \label{sec:distributed:construction}

% %% Figure: Looping distributed system
% \begin{figure}[!ht]
%     \centering%
%     % \vspace*{5pt}%
%     \begin{adjustbox}{max width=\linewidth}
%         \subfile{tex/tikz-distributed-looping}
%     \end{adjustbox}%
%     \caption{Looping distributed system.}%
%     \label{fig:looping-system}
% \end{figure}

% A \emph{compound negative scenario} is a sequence of \emph{compound scenario elements} $c_i$, where $c_i$ is an $M$-tuple of scenario elements for each synthesized module: ${c_i = \Tuple{s_i^m}}$, where ${s_i^m = \Pair{ i[\bar{x}], o[\bar{z}] }}$.

% Consider a system of two interconnected modules depicted in \cref{fig:looping-system}.
% The graph and the table in \cref{fig:looping-system} show the execution state sequence of this system, illustrating the violation of the LTL property: $\temp{GF} \neg z$.
% A compound negative scenario obtained from this execution sequence is shown below (the beginning of the loop is marked with an underline).
% \begin{equation*}
% \begin{aligned}
% [
%     &\Tuple{
%         \Pair{\ActionTT{R}{0}, \ActionMT{\varepsilon}{0}},
%         \Pair{\EmptyActionT{R}, \ActionTT{C}{1}}
%     };\\
%     &\underline{\Tuple{
%         \Pair{\ActionTT{R}{1}, \ActionTT{C}{1}},
%         \Pair{\EmptyActionT{R}, \ActionTT{C}{0}}
%     }}; \\
%     &\Tuple{
%         \Pair{\ActionTT{R}{0}, \ActionMT{\varepsilon}{1}},
%         \Pair{\EmptyActionT{R}, \ActionTT{C}{0}}
%     }; \\
%     &\Tuple{
%         \Pair{\ActionTT{R}{0}, \ActionMT{\varepsilon}{1}},
%         \Pair{\EmptyActionT{R}, \ActionTT{C}{1}}
%     }; \\
%     &\Tuple{
%         \Pair{\ActionTT{R}{1}, \ActionTT{C}{1}},
%         \Pair{\EmptyActionT{R}, \ActionTT{C}{0}}
%     };\\
%     &\Tuple{
%         \Pair{\ActionTT{R}{0}, \ActionTT{C}{1}},
%         \Pair{\EmptyActionT{R}, \ActionTT{C}{0}}
%     }
% ]
% \end{aligned}
% \end{equation*}

% One important difference from the monolithic case is that in distributed synthesis we assume that the input event might be empty: $i \in \SetInputEvents \union \{ \varepsilon \}$.
% This corresponds to the case when one of the modules does not receive any input at some point in time.
% We also assume that in valid scenarios $i = \varepsilon$ implies $o = \varepsilon$, i.e. if a module does not receive any input event, then it remains idle.
% Note that in negative traces derived from counterexamples obtained from the model checker, it might be the case that all synthesized modules do not receive an input event.
% It happens when all modules are idle, awaiting some input events from the environment.
% We filter out such elements, since they do not carry any information useful for the synthesis.

% % Note: this paragraph is partly incorrect: the projection is done on a tree level to preserve node indices
% % In order to constrain individual modules, we make the \emph{projection} of the compound negative scenario.
% % A \emph{projection} of a compound scenario $\{ s_i \}$ to a module $m$ is a sequence of $m$-th elements of this scenario.
% % We construct a negative scenario tree from projections in a similar fashion and proceed with negative mapping.
% % \textbf{TBD} rewrite this passage and illustrate it with an example.

% A \emph{compound negative scenario tree} (or \emph{compound tree}) $\NegativeCompoundTree$ is a negative scenario tree built from a set of compound negative scenarios in a similar way as described in \cref{sec:monolithic:trees}.
% Each node of $\NegativeCompoundTree$ and its incoming edge correspond to a compound scenario element.
% We denote the set of nodes of tree $\NegativeCompoundTree$ with $\SetNegativeCompoundTreeNodes$ and reuse the negative tree auxiliary functions ($\negtp{\negv}$, $\negtie{\negv}$, \etc) for the compound tree.

% A \emph{projection} of a compound scenario element to module $m$ is simply its $m$-th element.
% % $\ModularNegativeScenarioTree$ is a projection of a compound tree $\NegativeCompoundTree$ if every node of $\ModularNegativeScenarioTree$ is a projection of $\NegativeCompoundTree$.
% A \emph{projection} $\ModularNegativeTree$ of a compound tree $\NegativeCompoundTree$ to module $m$ is a tree isomorphic to $\NegativeCompoundTree$, each node of which is a projection of the scenario element in the respective node of $\NegativeCompoundTree$ to module~$m$.


\subsection{Составное негативное дерево сценариев}
\label{sec:distributed:construction}

\textit{Составной негативный сценарий} представляет собой последовательность \textit{составных элементов сценария}.
Каждый составной элемент~$c_i$ является $M$-кортежем элементов сценария для каждого синтезированного модуля: $c_i = (s_i^{(m)})_{m \in \Modules}$, где каждый $s_i^{(m)} = \Pair{ i[\bar{x}], o[\bar{z}] }$.

% TODO: fix picture (move the graph and the table on the second row, keeping the two automata on the first row)
%% Figure: Looping distributed system
\begin{figure}[!htb]
    \centering
    \begin{adjustbox}{max width=\linewidth}
        \subfile{tex/tikz-distributed-looping}
    \end{adjustbox}
    \caption{Циклическая распределенная система}
    \label{fig:looping-system}
\end{figure}

Рассмотрим систему из двух взаимосвязанных модулей, изображённую на Рисунке~\ref{fig:looping-system}.
Граф и таблица на Рисунке~\ref{fig:looping-system} демонстрируют последовательность состояний выполнения этой системы, иллюстрируя нарушение LTL-свойства ${ \Temp{GF} \neg z }$.
Составной негативный сценарий, полученный из этой последовательности выполнения, показан ниже (начало цикла отмечено подчеркиванием).
\begin{align*}
[
    &\Tuple{
        \Pair{\ActionTT{R}{0}, \ActionMT{\varepsilon}{0}},
        \Pair{\EmptyActionT{R}, \ActionTT{C}{1}}
    }; \\
    &\underline{\Tuple{
        \Pair{\ActionTT{R}{1}, \ActionTT{C}{1}},
        \Pair{\EmptyActionT{R}, \ActionTT{C}{0}}
    }}; \\
    &\Tuple{
        \Pair{\ActionTT{R}{0}, \ActionMT{\varepsilon}{1}},
        \Pair{\EmptyActionT{R}, \ActionTT{C}{0}}
    }; \\
    &\Tuple{
        \Pair{\ActionTT{R}{0}, \ActionMT{\varepsilon}{1}},
        \Pair{\EmptyActionT{R}, \ActionTT{C}{1}}
    }; \\
    &\Tuple{
        \Pair{\ActionTT{R}{1}, \ActionTT{C}{1}},
        \Pair{\EmptyActionT{R}, \ActionTT{C}{0}}
    }; \\
    &\Tuple{
        \Pair{\ActionTT{R}{0}, \ActionTT{C}{1}},
        \Pair{\EmptyActionT{R}, \ActionTT{C}{0}}
    }
]
\end{align*}

Одним из важных отличий от монолитного случая является то, что в распределённом синтезе предполагается, что входное событие может быть пустым: $i \in \SetInputEvents \union \{ \varepsilon \}$.
Это соответствует случаю, когда один из модулей не получает никаких входных данных в какой-то момент времени.
Также предполагается, что в допустимых сценариях ${i = \varepsilon}$ соответствует ${o = \varepsilon}$ \--- пока модуль не получает входных событий, он остаётся в состоянии простоя и ничего не продуцирует.
Следует отметить, что в негативных сценариях, полученных из контрпримеров модели, может случиться так, что все синтезированные модули не получают входного события.
Это происходит когда все модули находятся в состоянии простоя, ожидая входные события из окружающей среды.
Такие элементы фильтруются, так как они не содержат полезной информации для синтеза.

\textit{Составное негативное дерево сценариев} $\NegativeCompoundTree$ (далее просто \textit{составное дерево}) \--- это негативное дерево сценариев, построенное из набора составных негативных сценариев аналогичным образом, как описано в Разделе~\ref{sec:monolithic:trees}.
Каждая вершина дерева~$\NegativeCompoundTree$ и её входное ребро соответствуют \textit{составному элементу сценария}.
Множество вершин дерева~$\NegativeCompoundTree$ обозначается как~$\SetNegativeCompoundTreeNodes$, и для составного дерева повторно используются вспомогательные функции негативного дерева, такие как $\negtp{\negv}$, $\negtie{\negv}$ и другие.

\textit{Проекция} составного элемента сценария на модуль~$m$ \--- это просто его $m$-й элемент.
\textit{Проекция}~$\ModularNegativeTree$ составного дерева~$\NegativeCompoundTree$ на модуль~$m$ представляет собой дерево, изоморфное~$\NegativeCompoundTree$, каждая вершина которого является проекцией элемента сценария в соответствующей вершине дерева~$\NegativeCompoundTree$ на модуль~$m$.


% \subsection{Compound Negative Scenario Tree Mapping}
% \label{sec:distributed:mapping}

% Variable $\ModularNegativeMapping_{\negv}$ denotes the satisfying state in automaton $\ModularAutomaton$ for node $\negv \in \SetNegativeCompoundTreeNodes$, with $\ModularNegativeMapping_{\negv} = q_0$ in case when the automaton does not exhibit this particular behavior, and hence there is no satisfying state for $\negv$ (auxiliary state $q_0$ is common for all modules).
% For each module, the root node of the compound negative tree maps to the initial state of the corresponding automaton: $\ModularNegativeMapping_{\NegativeTreeRoot} = \ModularInitialState$.

% The projection of a compound tree may contain nodes with $i = \varepsilon$ on an incoming edge \--- we call such nodes \emph{idle}.
% Among non-idle nodes, we recognize passive (with $\negtoe{\negv} = \varepsilon$) and active nodes (with $\negtoe{\negv} \neq \varepsilon$) with the same properties as for regular negative trees.
% We denote the sets of idle, passive and active nodes of the compound negative tree as $\SetNegativeCompoundTreeNodesIdle$, $\SetNegativeCompoundTreeNodesPassive$, and $\SetNegativeCompoundTreeNodesActive$ respectively.

% The constraints for passive and active nodes are the same as in the reduction for monolithic synthesis.
% Each idle node maps to the same state as its parent.
% The only difference from passive nodes is that we do not need to encode that the automaton ignores an input action, since, in fact, it does not receive any:
% \[
%     (\ModularNegativeMapping_{\negv} = \ModularNegativeMapping_{\negtp{\negv}}) ,
% \]
% where
% ${\negv \in \SetNegativeCompoundTreeNodesIdle}$.

% Similar to the monolithic case, we ensure that if the node $\negv \in \SetNegativeCompoundTreeNodes$ is unmapped (\ie mapped to $q_0$), then this property is propagated down the tree:
% \begin{equation*}
%     (\ModularNegativeMapping_{\negtp{\negv}} = q_0)
%     \implies
%     (\ModularNegativeMapping_{\negv} = q_0) .
% \end{equation*}

% Finally, we need to prohibit the looping behavior described in counterexamples, but in such a way that each loop is prohibited in at least one module.
% This is done by adding a disjunction over $m \in \Modules$ for each loop:
% \begin{equation*}
% \begin{split}
%     \bigland_{\negv' \in \negtbe{\negv}}
%     \biglor_{m \in \Modules}
%         \left[
%             (\ModularNegativeMapping_{\negv} \neq \ModularNegativeMapping_{\negv'})
%             \lor
%             (\ModularNegativeMapping_{\negv} = \ModularNegativeMapping_{\negv'} = q_0)
%         \right] %.
% \end{split}
% \end{equation*}
% Thus, on each CEGIS iteration we accumulate clauses in the SAT formula to encode that this particular negative scenario is prohibited for at least one module.
% Essentially, this approach is an implicit search delegated to a SAT solver.


\subsection{Отображение составного негативного дерева сценариев}
\label{sec:distributed:mapping}

Переменная~$\ModularNegativeMapping_{\negv}$ обозначает удовлетворяющее состояние в автомате $\ModularAutomaton$ для вершины~$\negv \in \SetNegativeCompoundTreeNodes$, при этом $\ModularNegativeMapping_{\negv} = q_0$ в то случае, когда автомат не проявляет данного поведения, и, следовательно, не существует удовлетворяющего состояния для~$\negv$ (\enquote{фиктивное} состояние~$q_0$ является общим для всех модулей).
Для каждого модуля корневая вершина составного негативного дерева отображается на начальное состояние соответствующего автомата:
\[
    \ModularNegativeMapping_{\NegativeTreeRoot} = \ModularInitialState %.
\]

Проекция составного дерева может содержать вершины с $i = \varepsilon$ на входящем ребре \--- такие вершины называются \textit{пустыми}.
Среди непустых вершин различают пассивные ({$\negtoe{\negv} = \varepsilon$}) и активные вершины ({$\negtoe{\negv} \neq \varepsilon$}) с такими же свойствами, как и для обычных негативных деревьев.
Множества пустых, пассивных и активных вершин составного негативного дерева обозначаются как $\SetNegativeCompoundTreeNodesIdle$, $\SetNegativeCompoundTreeNodesPassive$ и~$\SetNegativeCompoundTreeNodesActive$ соответственно.

Ограничения для пассивных и активных вершин такие же, как в сведении для монолитного синтеза, описанного в разделе~\ref{sec:monolith-synthesis}.
Каждая \textit{пустая} вершина~$\negv \in \SetNegativeCompoundTreeNodesIdle$ отображается на то же состояние, что и её родительская вершина:
\[
    (\ModularNegativeMapping_{\negv} = \ModularNegativeMapping_{\negtp{\negv}}) ,
\]
Единственное отличие пустых вершин от пассивных вершин заключается в том, что не требуется явно кодировать, что автомат игнорирует входное действие, так как фактически он его не получает.

Аналогично монолитному случаю, необходимо обеспечить, чтобы если вершина $\negv \in \SetNegativeCompoundTreeNodes$ не отображается (отображется в фиктивное состояние~$q_0$), то это свойство передаётся вниз по дереву:
\[
    (\ModularNegativeMapping_{\negtp{\negv}} = q_0)
    \implies
    (\ModularNegativeMapping_{\negv} = q_0) %.
\]

Наконец, требуется запретить циклическое поведение, описанное в контрпримерах, но таким образом, чтобы каждый цикл был запрещён хотя бы в одном модуле.
Для этого добавляется дизъюнкция по~$m \in \Modules$ для каждого цикла в~$\NegativeCompoundTree$:
\[
    \bigland_{\negv' \in \negtbe{\negv}} \;
    \biglor_{m \in \Modules}
    \Bigl[
        (\ModularNegativeMapping_{\negv} \neq \ModularNegativeMapping_{\negv'})
        \lor
        (\ModularNegativeMapping_{\negv} = \ModularNegativeMapping_{\negv'} = q_0)
    \Bigr] %.
\]
Таким образом, на каждой итерации CEGIS в SAT-решатель добавляются ограничения на то, что данный негативный сценарий запрещён хотя бы для одного модуля.
По сути, этот подход представляет собой неявный поиск, делегированный SAT-решателю.


% \subsection{Finding a Minimal Distributed Controller}%
% \label{sec:distributed:minimal}

% Ultimately, we want to infer the \emph{minimal} distributed controller complying with the given specification $\LTLSpec$.
% Minimal models have more value in practice \--- they are much more comprehensible for humans and more efficient in the hardware.
% However, if we start minimizing (\eg by adding additional constraints) the solution \--- set of modules $\Set{\ModularAutomaton}$ \--- found by a CEGIS, the resulting minimal solution may (and, in practice, will) not comply with the specification $\LTLSpec$, though the already obtained negative scenarios will still not be satisfied, as expected.
% Therefore, the minimization step should be included into the CEGIS loop.
% Moreover, producing minimal models on each CEGIS iteration allows to perform model checking much faster, because smaller models have a smaller state space.
% Later we will refer to CEGIS with minimization included as CEGIS-min.

% In order to enable the minimization of the synthesized automata in terms of total number of states we perform the following extensions of the reduction to SAT\@.
% To begin with, observe that parameters $\ModularC$ \--- maximum number of states in each module $m \in \Modules$ \--- have to be known before the beginning of inference process, and the solution (if found) will have exactly the specified size (number of states).
% The simplest strategy for finding a satisfying solution with a minimal total number of states would be an iterative strategy \--- linear bottom-up search.
% However, in case of $M > 1$ (\ie any non-monolithic synthesis) it is unclear how to perform the iteration of parameters \--- efficiently, whereas maintaining the minimality \--- and this becomes a problem by itself.
% One possible way is to iterate all~$\ModularC$ altogether until we find some solution (all \enquote{too small} values result in UNSAT), and then try to decrease some of~$\ModularC$.
% However, the latter \--- inference with different $\ModularC$ values \--- requires \emph{restarts} of the SAT solver, since the declared variables (those with index $q \in \ModularSetStates$) and constraints depend on the $\ModularC$ \emph{statically}, \ie this parameter cannot be easily changed while preserving the satisfiability.
% Hence, we need a \emph{dynamic} way to gradually \enquote{disable} some states in the modules.
% This can be done using the \enquote{used states} approach proposed in~\cite{chivilikhin2020}.
% The main idea is to mark each state \emph{used}/\emph{unused}, which allows us to minimize the total number of \emph{used} states by encoding it with the \emph{totalizer}~\cite{sat-cardinality}.

% Variable $\StateUsed_{q} \in \Bool$ denotes whether the state $q$ is \emph{used} by an automaton, \ie is reachable from the initial state $\InitialState$.
% Clearly, the initial state is always \emph{used}.
% A~(non-initial) state is \emph{used} if and only if it has an incoming transition:
% \begin{equation*}
%     \StateUsed_{\InitialState}
%     \land
%     \bigland_{\mathclap{q \in \SetStates \setminus \Set{\InitialState}}}
%     \Bigl[
%         \StateUsed_{q}
%         \iff
%         \biglorclap{\substack{
%             q \in \SetStates \\
%             k \in [1..K]
%         }}
%         (\TransitionDestination_{q',k} = q)
%     \Bigr] .
% \end{equation*}
% Additionally, the following constraint ensures that unused states have the largest indices:
% % Note: this constraint is auxiliary
% \begin{equation*}
%     \neg\StateUsed_{q_i}
%     \implies
%     \neg\StateUsed_{q_{i+1}} %.
% \end{equation*}
% In the context of distributed synthesis, this variable is declared for each module ${m \in \Modules}$: $\ModularStateUsed_{q}$.
% The total number of used states in all modules is denoted~$\StatesUsed$ and encoded using the \emph{totalizer}~\cite{sat-cardinality}.
% % \StatesUsed = \bigsumclap{m \in \Modules, q \in \SetStates} \ModularStateUsed_{q}

% Symmetry-breaking constraints declared earlier (\cref{sec:monolithic:sat:structure} require the states of the automaton to be enumerated in the BFS traversal order, \ie to be included in the BFS traverse tree.
% This implies that all states (except the initial one) have an incoming transition, due to the definition of $\BfsParent{q}$ variable \--- parent of the state~$q$ in the BFS traverse tree.
% Consequently, this implies that all states are \emph{used}, by definition.
% In order to both reduce the search space by using the BFS constraints \emph{and} allow the states to be \emph{unused}, the former have to be modified in the following way.
% Modified variable $\BfsParentModified_{q_j} \in \Set{q_0, q_1, \dotsc, q_{j-1}}$ ($j \in [2..C]$) includes $q_0$ in its domain, which represents the absence of a parent for the state $q_j \in \SetStates$.
% Only \emph{unused} states do not have a parent:
% \begin{equation*}
%     \neg \StateUsed_{q_j}
%     \iff
%     (\BfsParentModified_{q_j} = q_0) .
% \end{equation*}
% Variable $\BfsTransition_{q_i, q_j} \in \Bool$ and all other constraints \--- definitions of $\BfsTransition$ and $\BfsParentModified_{}$, and the actual BFS constraint \--- do not require any additional changes.

% %% Algorithm: Distributed-CEGIS-min
% \subfile{tex/algo-cegis-min}

% The main procedure implementing the CEGIS-min is shown in \cref{alg:distributed-cegis-min}.
% First, we estimate parameter~$D$: the \emph{common} upper bound for the number of states in each module.
% The estimation is done by a simple bottom-up linear search.
% On each iteration we call the function $\texttt{infer}(\CommonArgs)$, where $\CommonArgs$ denotes the common arguments $\Tuple{ \Set{\ModularSetPositiveScenarios}, \SetNegativeCompoundScenarios, \allowbreak \Set{{\ModularC = \CompoundNumberOfStates}}, P }$.
% The $\texttt{infer}$ procedure is responsible for:
% \begin{enumerate}
%     \item building positive scenario trees for~$\Set{\ModularSetPositiveScenarios}$ and a negative compound scenario tree for~$\SetNegativeCompoundScenarios$;

%     \item reducing the inference problem to SAT by declaring the constraints described in this paper;

%     \item delegating to a SAT solver to actually solve the SAT problem;

%     \item building a solution \--- set of automata (modules)~$\Set{\ModularAutomaton}$ satisfying given scenarios \--- from the satisfying assignment found by the SAT solver.
% \end{enumerate}
% Next, we start an actual CEGIS loop.
% First, we minimize $\StatesUsed$ using a top-down approach.
% Here, we call $\texttt{infer}$ with an extra predicate\-/argument \enquote{$\StatesUsed < \texttt{UB}$}, where $\texttt{UB}$ denotes the upper bound for a total number of used (reachable) states in all synthesized automata.
% This predicate represents a \emph{cardinality constraint} which is encoded using a \emph{totalizer} technique~\cite{sat-cardinality}.
% Next, we minimize $\NodesUsed$ using the same approach.
% After that, we perform model checking of the synthesized distributed controller represented by automata~$\Set{\ModularAutomaton}$ for compliance with the given LTL\-/specification~$\LTLSpec$ using NuSMV~\cite{NuSMV} model checker, and obtain a set of negative compound scenarios $\SetNegativeCompoundScenariosNew$ \--- if there are any, they will be taken into account on the next iteration, else the CEGIS is done and $\Set{\ModularAutomaton}$ is the satisfying solution.


\subsection{Нахождение минимального распределённого контроллера}%
\label{sec:distributed:minimal}

Конечной целью является нахождение \emph{минимального} распределённого контроллера, соответствующего заданной спецификации $\LTLSpec$.
Минимальные модели имеют большую практическую ценность \--- они гораздо более понятны для человека и более эффективны в аппаратной реализации.
Однако, если начать минимизацию (\eg путём добавления дополнительных ограничений) решения \--- набора модулей $\Set{\ModularAutomaton}$ \--- найденного с помощью CEGIS, то полученное минимальное решение может (и, на практике, будет) не соответствовать спецификации $\LTLSpec$, хотя уже полученные негативные сценарии не будут удовлетворены, как и ожидалось.
Поэтому шаг минимизации должен быть включён в цикл CEGIS.
Более того, генерация минимальных моделей на каждой итерации CEGIS позволяет выполнять проверку модели гораздо быстрее, поскольку меньшие модели имеют меньшую пространство состояний.
В дальнейшем метод CEGIS с включённой минимизацией будет называться CEGIS-min.

Для обеспечения минимизации синтезированных автоматов по общему числу состояний выполняются следующие расширения редукции к SAT\@.
Во-первых, параметры $\ModularC$ \--- максимальное число состояний в каждом модуле $m \in \Modules$ \--- должны быть известны до начала процесса вывода, и решение (если найдено) будет иметь точно заданный размер (число состояний).
Самая простая стратегия для нахождения удовлетворяющего решения с минимальным общим числом состояний будет итеративной стратегией \--- линейный восходящий поиск.
Однако, в случае $M > 1$ (любого не монолитного синтеза) неясно, как выполнять итерацию параметров \--- эффективно, одновременно сохраняя минимальность \--- и это само по себе становится проблемой.
Одним из возможных способов является итерация всех~$\ModularC$ вместе до нахождения какого-либо решения (все \enquote{слишком малые} значения приводят к UNSAT), а затем попытка уменьшить некоторые из~$\ModularC$.
Однако, последнее \--- попытки синтеза с различными значениями~$\ModularC$ \--- требует \emph{перезапусков} SAT-решателя, поскольку объявленные переменные (с~индексом~$q \in \ModularSetStates$) и ограничения зависят от~$\ModularC$ \emph{статически} \--- этот параметр не может быть легко изменён с сохранением выполнимости формулы.
Таким образом, требуется \emph{динамический} способ постепенного \enquote{отключения} некоторых состояний в модулях.
Это можно сделать, используя подход \enquote{используемых состояний}, предложенный в~\cite{chivilikhin2020}.
Основная идея заключается в том, чтобы отметить каждое состояние как \textit{используемое} или \textit{неиспользуемое}, что позволяет минимизировать общее количество \textit{используемых} состояний, кодируя это с помощью техники \textit{totalizer}~\cite{sat-cardinality}.

Переменная~$\StateUsed_{q} \in \Bool$ обозначает, является ли состояние~$q$ \textit{используемым} автоматом \--- достижимо ли оно из начального состояния~$\InitialState$.
Очевидно, что начальное состояние всегда является \textit{используемым}.
(Не~начальное) состояние является \textit{используемым} тогда и только тогда, когда у него есть входной переход:
\[
    \StateUsed_{\InitialState}
    \land
    \bigland_{\mathclap{q \in \SetStates \setminus \Set{\InitialState}}}
    \Bigl[
        \StateUsed_{q}
        \iff
        \biglorclap{\substack{
            q \in \SetStates \\
            k \in [1..K]
        }}
        (\TransitionDestination_{q',k} = q)
    \Bigr] %.
\]
Дополнительно, следующее ограничение обеспечивает, что неиспользуемые состояния имеют наибольшие индексы:
% Note: this constraint is auxiliary
\[
    \neg\StateUsed_{q_i}
    \implies
    \neg\StateUsed_{q_{i+1}} %.
\]
В контексте распределённого синтеза эта переменная объявляется для каждого модуля~$m \in \Modules$: $\ModularStateUsed_{q}$.
Общее число используемых состояний во всех модулях обозначается~$\StatesUsed$ и кодируется с помощью \textit{totalizer}~\cite{sat-cardinality}.
% \StatesUsed = \bigsumclap{m \in \Modules, q \in \SetStates} \ModularStateUsed_{q}
% TODO: выразить общее число используемых состояний через totalizer

Описанные ранее ограничения нарушения симметрии (разделы \ref{sub:encoding-bfs-automaton} и~\ref{sub:encoding-bfs-guards}) требуют, чтобы состояния автомата были пронумерованы в порядке обхода BFS \--- были включены в дерево обхода BFS.
Это подразумевает, что, согласно определению переменной~$\BfsParent{q}$, все состояния (кроме начального) имеют входной переход \--- родителя состояния~$q$ в дереве обхода BFS.
Следовательно, это подразумевает, что все состояния \textit{используются}, по определению.
Для того чтобы уменьшить пространство поиска, используя ограничения BFS, и позволить состояниям быть \textit{неиспользуемыми}, BFS-предикаты должны быть изменены следующим образом.
Модифицированная переменная~$\BfsParentModified_{q_j} \in \Set{q_0, q_1, \dots, q_{j-1}}$ ($j \in [2..C]$) включает~$q_0$ в своё множество значений, что означает отсутствие родителя для состояния~$q_j \in \SetStates$ в дереве обхода BFS.
Только \textit{неиспользуемые} состояния не имеют родителя:
\[
    \neg\StateUsed_{q_j}
    \iff
    (\BfsParentModified_{q_j} = q_0) %.
\]
Переменная $\BfsTransition_{q_i, q_j} \in \Bool$ и все остальные ограничения \--- определения переменных $\BfsTransition$ и~$\BfsParentModified$, а также самого BFS-предиката \--- не требуют дополнительных модификаций.

%% Алгоритм: Distributed-CEGIS-min
\subfile{tex/algo-cegis-min}

Основная процедура, реализующая алгоритм $\AlgoCegisMin$, представлена на Листинге~\cref{alg:distributed-cegis-min}.
Сначала оценивается параметр~$D$: \emph{общее} верхнее значение для числа состояний в каждом модуле.
Оценка выполняется с помощью простого линейного восходящего поиска.
На каждой итерации вызывается функция $\texttt{infer}(\CommonArgs)$, где $\CommonArgs$~обозначает общие аргументы $\Tuple{ \Set{\ModularSetPositiveScenarios}, \SetNegativeCompoundScenarios, \allowbreak \Set{{\ModularC = \CompoundNumberOfStates}}, P }$.
Процедура $\texttt{infer}$ отвечает за:
\begin{enumerate}
    \item построение деревьев положительных сценариев для~$\Set{\ModularSetPositiveScenarios}$ и дерева составного негативного сценария для~$\SetNegativeCompoundScenarios$;

    \item редукцию задачи вывода к SAT путём объявления ограничений, описанных в данной работе;

    \item делегирование SAT-решателю для фактического решения задачи SAT;

    \item построение решения \--- набора автоматов (модулей)~$\Set{\ModularAutomaton}$, удовлетворяющих заданным сценариям, из удовлетворяющего присваивания, найденного SAT-решателем.
\end{enumerate}
Далее начинается фактический цикл CEGIS.
Сначала минимизируется~$\StatesUsed$ с использованием нисходящего подхода.
Здесь вызывается $\texttt{infer}$ с дополнительным аргументом-предикатом \enquote{$\StatesUsed < \texttt{UB}$}, где $\texttt{UB}$ обозначает верхнюю границу для общего числа использованных (достижимых) состояний во всех синтезированных автоматах.
Этот предикат представляет собой \textit{ограничение на кардинальность}, которое кодируется с использованием техники \textit{totalizer}~\cite{sat-cardinality}, описанной в разделе~\ref{sec:cardinality}.
Затем минимизируется~$\NodesUsed$ с использованием того же подхода.
После этого проводится проверка модели синтезированного распределённого контроллера, представленного автоматами~$\Set{\ModularAutomaton}$, на соответствие заданной LTL\-/спецификации~$\LTLSpec$ с использованием проверщика моделей NuSMV~\cite{NuSMV}, и получается набор составных негативных сценариев $\SetNegativeCompoundScenariosNew$ \--- если такие есть, они будут учтены на следующей итерации, иначе CEGIS завершается, и $\Set{\ModularAutomaton}$ является искомым решением \--- системой из $M$ автоматов, удовлетворяющей заданным примерам поведения и LTL\-/спецификации.



% \subfile{tex/sec-exp-modular}
\section{Экспериментальное исследование: модульный синтез}%
\label{sec:experiments-modular}

% DC: В ВЫВОДАХ МОЖНО ДОПИСАТЬ, ЧТО ДЛЯ УСКОРЕНИЯ МЕТОДОВ ИЗ ТАБЛИЦЫ 4 МОГУТ ПОТРЕБОВАТЬСЯ ДОПОЛНИТЕЛЬНЫЕ СИММЕТРИ БРЕЙКИНГИ

% Here goes text

В данном разделе приводится экспериментальное исследование, посвященное применению разработанных методов для синтеза модульных конечно-автоматных моделей логических контроллеров с различными композициями модулей, входящих в состав композитного функционального блока: (1)~параллельной, (2)~последовательной и (3)~произвольной.
В качестве примера была использована система PnP\-/манипулятора, уже рассмотренная ранее в разделе~\ref{sec:experiments-monolith-pnp}.
% Система PnP\-манипулятора была рассмотрена ранее, в разделе~\ref{sec:experiments-monolith-pnp}, в контексте монолитного синтеза.
Несмотря на то, что исходная модель контроллера PnP\-/манипулятора является монолитной, модульный синтез позволяет синтезировать распределенную систему, реализующую схожее поведение.

Стоит отметить, что приведенное экспериментальное исследование не включает в себя сравнение с существующими методами, так как двухэтапный метод \enquote{Two-stage}~\cite{chivilikhin-19}, использованный в главе~\ref{ch:automata-synthesis} неприменим к задаче модульного синтеза, а среди доступных инструментов для задачи модульного синтеза можно выделить только EFSM-tools~\cite{efsm-tools}, однако данное решение обладает следующими недостатками: (1)~низкая эффективность (по критериям времени работы и размерам моделей) на задаче монолитного синтеза, что подтверждено в~\cite{chivilikhin-19}, (2)~модульное разбиение должно быть известно заранее, так как его необходимо указывать вручную, в то время как разработанные в данной работе методы позволяют получать модульное разбиение автоматически.

В первом эксперименте были использованы методы для синтеза \textit{базовой} модульной модели, состоящей из двух модулей: ${M = 2}$.
В качестве входных данных были использованы наборы сценариев $\SetScenarios^{(1)}$, $\SetScenarios^{(4)}$ и~$\SetScenarios^{(39)}$, где верхний индекс означает число сценариев в наборе.
В~экспериментальном сравнении были использованы алгоритмы $\AlgoModularParallelBasicMin$, $\AlgoModularConsecutiveBasicMin$ и $\AlgoModularArbitraryBasicMin$.
Результаты первого эксперимента представлены в таблице~\ref{tab:results-modular-basicmin}, где
$\SetPositiveScenarios$ \=== набор сценариев выполнения,
$\card{\PositiveTree}$ \=== размер дерева сценариев,
$\Cmin$ \=== минимальное число состояний (одинаковые значения для каждого модуля),
$\Tmin$ \=== минимальное число переходов (указаны по-отдельности для каждого модуля: $\Tmin^{(1)}$+$\Tmin^{(2)}$),
\enquote{Время, с} \--- время работы в секундах.
Полученные результаты показывают, что методы синтеза минимальных модульных моделей с параллельной и последовательной композициями модулей обладают хорошей мастшабируемостью \--- время работы на большом наборе сценариев $\SetScenarios^{(39)}$ можно субъективно считать небольшим.
Что же касается произвольной композиции \--- результаты показывают, что эта задача является непростой и плохо мастабируется с ростом размера сценариев.
% однако стоит отметить, что б\'{о}льшую часть времени занимает именно процесс минимизации модели, а первое решение (неоптимальная модель) находится сравнительно быстро: результаты не приводятся, но для справки для $\SetScenarios^{(39)}$ время синтеза начальной модели порядка 200 секунд.
Низкую эффективность метода синтеза с произвольной композицией можно объяснить тем, что сведение (формула в КНФ для SAT-решателя) получается значительных размеров (для $\SetScenarios^{(39)}$ $\approx 2.5$~миллиона переменных, $\approx 45$~миллионов дизъюнктов), что соответствует большому пространству поиска, перебираемому в процессе минимизации.
В~таких случаях обычно используются техники нарушения симметри (помимо уже рассмотренных в разделах~\ref{sub:encoding-bfs-automaton} и~\ref{sub:encoding-bfs-guards} BFS\-/предикатов нарушения симметрии), однако в данной работе их исследование и разработка не проводились.

%% Table: Results for Modular-*-BasicMin
\begin{table}[!htb]
    \centering
    \caption{Результаты синтеза базовых модульных конечно-автоматных моделей логического контроллера PnP-манипулятора}
    \label{tab:results-modular-basicmin}
    \subfile{tex/tab-modular-basicmin-results}
\end{table}

Аналогичным образом было проведено экспериментальное исследование методов синтеза \textit{расширенных} модульных моделей, охранные условия которых представлены в виде явных произвольных булевых формул.
При синтезе были использованы заранее выбранные значения параметра~$P$.
% без использования автоматизированного подбора оптимального значения, как это производится в алгоритме $\AlgoExtendedMinUB$.
% Данное допущение обусловлено тем, что это достаточно сложно реализовать, да и результаты были бы ЕЩЁ хуже.
В экспериментальном сравнении были использованы алгоритмы $\AlgoModularParallelExtendedMin$ и $\AlgoModularConsecutiveExtendedMin$.
Алгоритм $\AlgoModularArbitraryExtendedMin$ не был рассмотрен, так как задача синтеза расширенной модели значительно сложнее синтеза базовой, а алгоритм $\AlgoModularArbitraryBasicMin$ показал крайне низкую эффективность в предыдущем эксперименте.
Результаты второго эксперимента представлены в таблице~\ref{tab:results-modular-extmin}, где
$\SetPositiveScenarios$ \=== набор сценариев выполнения,
$\card{\PositiveTree}$ \=== размер дерева сценариев,
$\Cmin$ \=== минимальное число состояний в каждом модуле (одинаковые значения для каждого модуля),
$P$ \=== максимальный размер охранного условия,
$T$ \=== число переходов (не было минимизировано) (указаны по-отдельности для каждого модуля: {$T^{(1)}$+$T^{(2)}$}),
$\Nmin$ \=== минимальный суммарный размер охранных условий (указаны по-отдельности для каждого модуля: $\Nmin^{(1)}$+$\Nmin^{(2)}$),
\enquote{Время,~с} \--- время работы в секундах.

%% Table: Results for Modular-*-ExtendedMin
\begin{table}[!htb]
    \centering
    \caption{Результаты синтеза расширенных модульных конечно-автоматных моделей логического контроллера PnP-манипулятора}
    \label{tab:results-modular-extmin}
    \subfile{tex/tab-modular-extmin-results}
\end{table}

Анализируя полученные результаты, можно прийти к выводу, что разработанные методы синтеза расширенных модульных моделей работают корректно, однако в целом неэффективно.
Можно заметить, что в случае параллельной и произвольной композиций основным результатом методов синтеза базовых моделей являются не сами модели, а модульное разбиение \--- соответствие переменных модулям, которые ими управляют.
При переходе к синтезу расширенной модели уже полученное модульное разбиение может быть зафиксировано, что положительно скажется на скорости решения ввиду того, что пространство поиска будет меньше, однако финальная модель в общем случае уже не будет минимальной.


\vspace{3ex}
\chapterconclusion

В данной главе была рассмотрена и решена задача синтеза минимальных конечно-автоматных моделей модульных логических контроллеров с различными видами композиции модулей: (1)~параллельной, (2)~последовательной и (3)~произвольной.
Разработанные методы были проверены в ходе экспериментального исследования, посвященного синтезу конечно-автоматной модели контроллера Pick-and-Place манипулятора.
Реализация методов включена в разработанное программное средство \smallcaps{fbSAT}~\cite{fbSAT-tool}.

% \nopagebreak\vspace{3ex}
% \printfleuron
