\chapter{Синтез конечно-автоматных моделей модульных логических контроллеров}%
\label{ch:modular-synthesis}

Данная глава посвящена решению задачи синтеза конечно-автоматных моделей модульных логических контроллеров с различными видами композиции модулей: (1)~параллельная (раздел~\ref{sec:modular-parallel-synthesis}), (2)~последовательная (раздел~\ref{sec:modular-consecutive-synthesis}) и (3)~произвольная (раздел~\ref{sec:modular-arbitrary-synthesis}).
Раздел~\ref{sec:experiments-modular} содержит экспериментальное исследование, нацеленное на определение эффективности и применимости разработанных методов модульного синтеза.
% В качестве модельной системы используется система Pick-and-Place манипулятора, уже рассмотренная ранее в разделе~\ref{sec:experiments-monolith-pnp}.
% Несмотря на то, что оригинальная система фактически является монолитной, разработанные методы позволяют синтезировать распределенную модульную систему, обладающую схожим поведением.


% TODO: what is that?
% \subfile{tex/sec-composite-fb-model}

% \subfile{tex/sec-modular-parallel-synthesis}
\section{Метод синтеза конечно-автоматных моделей модульных логических контроллеров с параллельной композицией модулей по примерам поведения}%
\label{sec:modular-parallel-synthesis}

В этом разделе рассматривается задача синтеза конечно-автоматной модели модульного контроллера с параллельной композицией модулей.
Аналогично главе~\ref{ch:monolith-synthesis}, исходная задача сводится к задаче выполнимости SAT.
Полученное сведение состоит из двух компонент: (1)~определение переменных и (2)~определение ограничений.


\subsection{Сведение к SAT: переменные}%
\label{sub:modular-parallel-variables}

При параллельной композиции для описания каждого модуля используются те же переменные, что и при монолитном синтезе.
Таким образом, ко всем переменным добавляется верхний индекс $(m)$, где $m \in \Modules$.
Дополнительно, объявляется переменная $\ModuleControllingOutputVariable{z} \in \Modules$, кодирующая модуль, управляющий выходной переменной $z \in Z$.
В данной постановке задачи рассматривается ситуация, когда каждый из модулей \enquote{управляет} своим собственным набором выходных переменных $\SetOutputVariables^{(m)} \subset \SetOutputVariables$, причём эти наборы попарно не пересекаются.
Стоит отметить, что в общем случае эти наборы неизвестны заранее, а определяются динамически в ходе решения задачи SAT.
Возможна также ситуация, когда полное или частичное распределение переменных по модулям известно \--- в таком случае разработанный метод позволяет это учесть путём введения дополнительных ограничений на описанную переменную $\ModuleControllingOutputVariable*$.


\subsection{Сведение к SAT: ограничения}%
\label{sub:modular-parallel-constraints}

При модульном синтезе ограничения так же, как и при монолитном синтезе, делятся на две группы: (1)~ограничения, кодирующие структуру синтезируемого (модульного) автомата, (2)~ограничения, кодирующие соответствие поведения синтезируемого (модульного) автомата дереву сценариев.

Для кодирования структуры каждого модуля, входящего в состав модульного автомата, используются те же ограничения, что и при монолитном синтезе.
Дополнительно, вводятся следующие ограничения:
\begin{itemize}
    \item каждая выходная переменная $z \in \SetOutputVariables$ управляется ровно одним модулем:
    \[
        \ExactlyOne[m \in \Modules]{\ModuleControllingOutputVariable{z} = m}
    \]

    \item каждый модуль $m \in \Modules$ управляет хотя бы одной выходной переменной:
    \[
        \AtLeastOne[z \in \SetOutputVariables]{\ModuleControllingOutputVariable{z} = m}
    \]

    \item если выходная переменная $z \in \SetOutputVariables$ не управляется модулем $m \in \Modules$, то алгоритмы во всех состояниях $q \in \SetStates$ модуля $m$ \enquote{ничего не делают}, то есть переводят $\top$ в $\top$ и $\bot$ в $\bot$:
    \[
        (\ModuleControllingOutputVariable{z} \neq m)
        \implies
        \biglandclap{q \in \SetStates}
        \left[
            (\ModularStateAlgorithm{q,z,\top} = \top)
            \land
            (\ModularStateAlgorithm{q,z,\bot} = \bot)
        \right]
    \]
\end{itemize}

В свою очередь ограничения, кодирующие соответствие поведения синтезируемого модульного автомата дереву сценариев, отличаются от аналогичных при монолитном синтезе.
Для отображения пассивных вершин $\SetTreeNodesPassive$ дерева сценариев используются те же ограничения, что и при монолитном синтезе.
А при отображении активных вершин $\SetTreeNodesActive$ дерева сценариев $\PositiveTree$ на состояния $\SetStates$ каждого модуля $m \in \Modules$ необходимо дополнительно учитывать контролируемые этим модулем выходные переменные:

\begin{equation}
\label{eq:constraint-mapping}
\begin{split}
    \biglandsmashl{\substack{
        m \in \Modules \\
        v \in \SetTreeNodesActive \\
        q \in Q }}
    % \bigland{q \in Q}
    \Bigl[
        (\ModularMapping{v} = q)
        % \iff
        \implies
        (\ModularActualTransitionFunction{q',e,u} = q)
        \land
        (\ModularStateOutputEvent{q} = o)
        \land
    \Bigr.\\
    \Bigl.
        \land % from previous line
        \biglandclap{z \in Z}
        \left(
            (\ModuleControllingOutputVariable{z} = m)
            \implies
            (\ModularStateAlgorithm{q,z,\tov{p,z}} = \tov{v,z})
        \right)
    \Bigr]
    ,
\end{split}
\end{equation}
где $p = \tp{v}$, $q' = \ModularMapping{p}$, $e = \tie{v}$, $u = \tin{v}$, $o = \toe{v}$.

Дополнительно, необходимо гарантировать корректность выходных событий модулей для соответствия дереву сценариев.
Для этого рассмотрим обработку модульным автоматом некоторого входного действия~$\InputAction$ из некоторой \emph{активной} вершины~$v$ дерева сценариев (то есть $\toe{v} \neq \varepsilon$).
Каждый параллельный модуль $m \in \Modules$, входящий в состав модульного автомата, в ответ на входное действие генерирует выходное действие~$\OutputAction[(m)]$.
Возникает необходимость некоторым образом объединить эти выходные действия в одно~$\OutputAction$, которое будет являться финальной реакцией модульного автомата на исходное входное действие~$\InputAction$.
Фактически, необходимо использовать специальный функциональный блок, называемый в IEC~61499 \texttt{E\_MERGE}, реализующий объединение событий.
Существует несколько способов такого объединения: (1)~синхронное \emph{rendezvous}, (2)~асинхронное \emph{rendezvous}, (3)~\emph{гибридное}.

Синхронное \emph{rendezvous} подразумевает ожидание завершения работы всех модулей, при этом корректной считается ситуация, когда выходные события всех модулей совпадают.
При формировании выходного действия~$\OutputAction$ используется общее выходное событие~$\OutputEvent$, а обновленные значения выходных переменных~$\OutputValues_{(m)}$ просто конкатенируются в $\OutputValues$, так как множества $\SetOutputVariables^{(m)}$ попарно не пересекаются.
Стоит отметить, что в этом случае ни один модуль не должен игнорировать входное действие, то есть не должен генерировать пустое событие $\OutputEvent = \varepsilon$.

\texttt{E\_MERGE} с асинхронным \emph{rendezvous} генерирует выходное действие равное входному, не ожидая завершения работы всех модулей
При этом модульный автомат, использующий такой тип объединения событий, в ответ на некоторое входное действие $\InputAction$ может реагировать несколькими выходными действиями.
Корректной считается следующая ситуация: каждый модуль генерируют либо выходное событие~$\OutputEvent$, либо пустое событие~$\varepsilon$; хотя бы один модуль генерирует непустое событие; объединение обновленных значений выходных переменных равно~$\OutputValues$.
Здесь~$\OutputAction$ \--- выходное действие, записанное в обрабатываемой активной вершине дерева сценариев.
Такая ситуация нарушает соответствие поведения модульного автомата дереву сценариев, однако может являться допустимой в реальном мире, так как последовательность выходных действий в ответ на одно входное все равно приводит систему к корректному состоянию с точки зрения значений выходных переменных.

Гибридный способ объединения событий является совокупностью синхронного и асинхронного \emph{rendezvous}.
Гибридный \texttt{E\_MERGE} генерирует ровно одно выходное событие (\enquote{асинхронное} поведение), при этом непустых входных событий может быть несколько, и все они учитываются для генерации совместного события.
Это достигается тем, что гибридный блок ожидает завершения работы всех модулей (\enquote{синхронное} поведение) лишь некоторое ограниченное время.
При этом считается, что все неответившие модули игнорировали входное действие, а значит, продуцировали пустое выходное событие~$\varepsilon$.
Корректной считается ситуация, когда каждый модуль генерируют либо выходное событие~$\OutputEvent$, либо пустое событие~$\varepsilon$, а объединение обновленных значений выходных переменных равно~$\OutputValues$, где~$\OutputAction$ \--- выходное действие, записанное в обрабатываемой активной вершине дерева сценариев.

В приведенном выше ограничении (\ref{eq:constraint-mapping}), кодирующем отображение активных вершин дерева на состояния модулей, используется синхронный вариант объединения выходных событий.
% TODO: Потому что...


\subsection{Алгоритмы \AlgoModularParallelBasic\ и \AlgoModularParallelExtended}%
\label{sub:algorithm-modular-parallel-basic-and-extended}

Обозначим $\AlgoModularParallelBasicFull(\SetPositiveScenarios, M, C, T)$ алгоритм, реализующий синтез модели, удовлетворяющей заданным сценариям выполнения $\SetPositiveScenarios$ и состоящей из $M$ \emph{параллельно} соединенных модулей, каждый из которых состоит $C$ состояний (то есть суммарное число состояний равно $M \cdot C$), а суммарное число переходов во всех модулях не больше $T$.
Также введем обозначение $\AlgoModularParallelBasic(\SetPositiveScenarios, M, C) =\allowbreak \AlgoModularParallelBasicFull(\SetPositiveScenarios, M, C, {T=\infty})$ для случая, когда число переходов в автомате остается неограниченным.

Отметим, что модификации сведения для синтеза расширенных моделей не отличаются от описанных в главе~\ref{ch:monolith-synthesis} \--- структура охранных условий кодируется независимо от количества модулей и их композиции.
Поэтому здесь и далее алгоритмы, реализующие синтез расширенных моделей, будут объявляться без пояснений:
$\AlgoModularParallelExtendedFull(\SetPositiveScenarios, M, C, P, N)$ и $\AlgoModularParallelExtended(\SetPositiveScenarios, M, C, P) = \AlgoModularParallelExtendedFull(\SetPositiveScenarios, M, C, P, N=\infty)$.


% \subfile{tex/sec-modular-consecutive-synthesis}
\section{Метод синтеза конечно-автоматной модели модульного логического контроллера с последовательной композицией модулей по примерам поведения}%
\label{sec:modular-consecutive-synthesis}

Последовательная композиция модулей значительно отличается от параллельной, так как модули в таком случае перестают быть независимыми \--- каждый следующий модуль зависит от предыдущего.
В данной работе рассматривалась постановка задачи синтеза модульного контроллера со следующими особенностями и допущениями: (1) каждый модуль зависит от всех входных переменных \emph{внешнего} (модульного) автомата, (2) значения выходных переменных каждого модуля зависят от предыдущих значений выходных переменных предыдущего модуля (для первого модуля \enquote{предыдущим} считается он сам), (3) входное событие обрабатывается (то есть происходит генерация ответного выходного события) только последним модулем, до которого оно неизменно передается от модуля к модулю.
% TODO: картинка


\subsection{Сведение к SAT: переменные}%
\label{sub:modular-consecutive-variables}

Аналогично параллельной композиции, структура каждого модуля кодируется так же, как и при монолитном синтезе, с учетом допущения о том, что только последний модуль реагирует на входные события, а все предыдущие модули просто неизменно передают полученное входное событие далее \--- это достигается тем, что множества выходных событий каждого модуля приравниваются множеству входных событий ($\forall m \in [1 \twodots (M-1)] : O^{(m)} = E$).
Дополнительно объявляется переменная $\ModularComputedValue{v,z} \in \Bool$, кодирующая \enquote{вычисленное} значение выходной переменной $z \in \SetOutputVariables$ при отображении каждой вершины $v \in \SetTreeNodes$ дерева сценариев, то есть значение в каждый момент времени после обработки соответствующей вершины дерева.


\subsection{Сведение к SAT: ограничения}%
\label{sub:modular-consecutive-constraints}

Для определения переменной $\ModularComputedValue{}$ объявляются следующие ограничения.
Изначально, в момент времени после \enquote{обработки} фиктивного корня $\TreeRoot$ дерева сценариев, вычисленные значения всех выходных переменных $z \in \SetOutputVariables$ во всех модулях $m \in \Modules$ равны \texttt{False}:
\[
    \bigland{m \in \Modules}
    \bigland{z \in \SetOutputVariables}
    (\ModularComputedValue{\TreeRoot,z} = \bot) .
\]
В следующие моменты времени, при обработке вершин $v \in \SetTreeNodes \setminus \Set{\TreeRoot}$, вычисляемые значения выходных переменных определяются в соответствии с работой алгоритмов в состояниях, в которых в эти моменты времени находятся модули \--- то есть в состояниях, в которые отображаются рассматриваемые вершины дерева сценариев: $\ModularMapping{v}$. \\
Для первого модуля:
\[
    \bigland{v \in \SetTreeNodes \setminus \Set{\TreeRoot}}
    \bigland{z \in \SetOutputVariables}
    \left[
        \ModularComputedValue{v,z}
        \iff
        \ModularStateAlgorithm{\ModularMapping{v},z,\tov{\tp{v},z}}
    \right] .
\]
Для последующих модулей:
\[
    \bigland{m \in [2 \twodots M]}
    \bigland{v \in \SetTreeNodes \setminus \Set{\TreeRoot}}
    \bigland{z \in \SetOutputVariables}
    \left[
        \ModularComputedValue{v,z}
        \iff
        \ModularStateAlgorithm{\ModularMapping{v},z,\ModularComputedValue[m-1]{v,z}}
    \right] .
\]

При отображении активных вершин дерева необходимо учесть, что все модули, кроме последнего, передают входное событие следующему модулю. Стоит отметить, что при этом реакция модулей на входные события не изменяется \--- входные события так же играют свою роль в охранных условиях на переходах автомата.
Также необходимо учесть, что значения выходных переменных ограничиваются для соответствия дереву сценариев только для последнего модуля \--- все предыдущие модули могут производить произвольные операции над выходными переменными в рамках существующего сведения.
\begin{gather*}
    \biglandsmashl{v \in \SetTreeNodesActive}
    \bigland{m \in [1 \twodots (M-1)]}
    \bigland{q \in Q}
    \left[
        (\ModularMapping{v} = q)
        \implies
        (\ModularActualTransitionFunction{q',e,u} = q)
        \land
        % Note: "outputevent = e", THIS IS NOT A TYPO
        (\ModularStateOutputEvent{q} = e)
    \right] , \\
    \biglandsmashl{v \in \SetTreeNodesActive}
    \bigland{q \in Q}
    \left[
        (\ModularMapping[M]{v} = q)
        \implies
        (\ModularActualTransitionFunction[M]{q',e,u} = q)
        \land
        (\ModularStateOutputEvent[M]{q} = o)
        \land
        \biglandclap{z \in \SetOutputVariables}
        (\ModularComputedValue[M]{v,z} = \tov{v,z})
    \right] ,
\end{gather*}
где $p = \tp{v}$, $q' = \ModularMapping{p}$, $e = \tie{v}$, $u = \tin{v}$.

При отображения пассивных вершин достаточно закодировать тот факт, что все модули игнорируют входное воздействие, то есть автоматы не изменяют своего состояния.
\[
    \biglandsmashl{v \in \SetTreeNodesPassive}
    \bigland{m \in \Modules}
    (\ModularActualTransitionFunction{q',e,u} = 0) ,
\]
где $p = \tp{v}$, $q' = \ModularMapping{p}$, $e = \tie{v}$, $u = \tin{v}$.


\subsection{Алгоритмы \AlgoModularConsecutiveBasic\ и \AlgoModularConsecutiveExtended}%
\label{sub:algorithm-modular-consecutive-basic-and-extended}

Аналогично разделу~\ref{sub:algorithm-modular-parallel-basic-and-extended}, обозначим $\AlgoModularConsecutiveBasicFull(\SetPositiveScenarios, M, C, T)$ алгоритм, реализующий синтез модульной модели с \emph{последовательной} композицией модулей.
Также введем обозначение $\AlgoModularConsecutiveBasic(\SetPositiveScenarios, M, C) =\allowbreak \AlgoModularConsecutiveBasicFull(\SetPositiveScenarios, M, C, T=\infty)$.
В соответствии с разделом~\ref{sub:algorithm-modular-parallel-basic-and-extended}, алгоритм для синтеза расширенных моделей объявляется без пояснений:
\resizebox{.99\hsize}{!}{$\AlgoModularConsecutiveExtended(\SetPositiveScenarios, M, C, P) = \AlgoModularConsecutiveExtendedFull(\SetPositiveScenarios, M, C, P, N=\infty)$}.



% \subfile{tex/sec-modular-arbitrary-synthesis}
\section{Метод синтеза конечно-автоматных моделей модульных логических контроллеров с произвольной композицией модулей по примерам поведения}%
\label{sec:modular-arbitrary-synthesis}

Наиболее общей формулировкой задачи синтеза конечно-автоматных моделей логических контроллеров является модульный синтез с произвольной композицией модулей.
Каждый модуль рассматривается как черный ящик с набором входных и выходных контактов для входных/выходных событий/переменных. Содержимое черного ящика \--- монолитный контроллер, структура которого кодируется так же, как при монолитном синтезе.
Совокупность модулей является внутренним содержимым модульного контроллера, так же обладающего входными и выходными \emph{контактами}.
Контакты соединяются \emph{связями}, что обеспечивает взаимодействие модулей друг с другом.
При такой постановке задачи, разрабатываемый метод обладает максимальными возможностями для синтеза комплексных модульных структур, и является свободным от ограничений, присущих рассмотренным ранее параллельной и последовательной композициям.
Стоит отметить, что для корректных вычислений выходных событий и значений выходных переменных необходимо знать порядок вычисления модулей, что возможно только если граф связей модулей является ацикличным.
Данное ограничение не уменьшает вычислительной способности модульного контроллера, поэтому в данной работе предполагается, что граф связей модулей является ацикличным, а также то, что модули упорядочены в порядке их номеров: от~1 до~$M$.

% \begin{figure}
%     % \includegraphics[max width=0.9\textwidth]{img/modular.png}
%     \includegraphics[max width=0.9\textwidth]{img/modular_full.png}
%     \caption{Пример модульного автомата с произвольной композицией}%
%     % \label{fig:my_label}
% \end{figure}


\subsection{Сведение к SAT: переменные}%
\label{sub:modular-arbitrary-variables}

Рассмотрим подробнее, как устроено сведение для модульного синтеза с произвольной композицией.
Обозначим $\ModularSetInboundVarPins = \Set{(m-1) \cdot \card{\SetInputVariables} + 1, \dotsc,\allowbreak m \cdot \card{\SetInputVariables}}$ множество входных контактов для переменных, считая, что контакты нумеруются натуральными числами, начиная с единицы, а нумерация является сквозной среди всех модулей $m \in \Modules$ для всех контактов одного типа.
Аналогично, обозначим $\ModularSetOutboundVarPins$ множество выходных контактов для переменных, а также обозначим множества входных и выходных контактов для событий $\ModularSetInboundEventPins$ и $\ModularSetOutboundEventPins$.
Дополнительно, обозначим множества контактов для внешнего (модульного) автомата следующим образом: $\SetExternalInboundVarPins$, $\SetExternalOutboundVarPins$, $\SetExternalInboundEventPins$, $\SetExternalOutboundEventPins$.
Отметим, что, например, множество $\SetExternalInboundVarPins$ внешних входных контактов для переменных соответствует выходным переменным~$\SetOutputVariables$, так как эти контакты являются входами для входящих в них связей из выходных контактов.
При этом нумерация внешних контактов продолжает нумерацию модульных того же типа, например, $\SetExternalInboundVarPins = \Set{M \cdot \card{\SetInputVariables} + 1, \dotsc, M \cdot \card{\SetInputVariables} + \card{\SetOutputVariables}}$
Для упрощения используемой нотации обозначим множества \emph{всех} входных/выходных контактов для переменных/событий $\SetInboundVarPins$, $\SetOutboundVarPins$, $\SetInboundEventPins$, $\SetOutboundEventPins$, где, например, $\SetInboundVarPins = \bigunionnolim{m \in \Modules} \ModularSetInboundVarPins \union \SetExternalInboundVarPins$.

Следующий шаг \--- определение графа соединений контактов модулей.
Введем переменные $\VarPinParent{p} \in \SetOutboundVarPins$ и $\EventPinParent{p} \in \SetOutboundEventPins$, обозначающие родителя входного контакта $p$ для переменных/событий.
Можно заметить, что родителем входного контакта может быть только выходной контакт.
Если контакт является родителем другого, то они соединены \emph{связью}, и обновление значения родителя приводит к обновлению значения ребенка.
Пользуясь допущением об ацикличности графа соединений модулей, определим, что родителем входного контакта $p$ может быть выходной контакт из модуля с меньшим номером, либо внешний выходной контакт, например, для некоторого контакта $p \in \SetInboundVarPins$ из модуля $m$: $\VarPinParent{p} \in \SetExternalOutboundVarPins \union \bigunionnolim{m' < m} \ModularSetOutboundVarPins[m']$.

Для каждого контакта необходимо кодировать его вычисленное значение в каждый момент времени в процессе отображения вершин дерева сценариев на состояния модулей.
Для этого вводятся переменные $\InboundVarPinComputedValue{v,p}$~и~$\OutboundVarPinComputedValue{v,p}$, кодирующие значения входных/выходных контактов $p \in \SetInboundVarPins$ / $p \in \SetOutboundVarPins$ в момент времени после обработки вершины $v$ дерева сценариев.

Важно отметить, что в отличие от рассмотренных ранее методов, при произвольной композиции каждый модуль может получать на вход произвольные наборы значений входных переменных.
Всего существует $2^{\card{\SetInputVariables}}$ таких наборов, и каждый из них должен быть корректно обработан каждым модулем.
Поэтому при кодировании структуры автомата необходимо учитывать множество всех возможных различных входов $\SetAllInputs = \boolvec{\SetInputVariables} = \Set{\Vector{0 \dots 0}, \dotsc, \Vector{1 \dots 1}}$, а не только множество входов $\SetTreeInputs \subseteq \SetAllInputs$, встречающихся в дереве сценариев.
Введем переменную $\ModularInputIndex{v} \in \SetAllInputs$, обозначающую вход в момент времени после обработки вершины~$v$ дерева сценариев.
Заметим, что вычисленные значения $\InboundVarPinComputedValue{v,p}$ входных контактов являются битами в бинарной записи номера входа~$u \in \SetAllInputs$, учитывая, что входы нумеруются с нуля.
Для взаимосвязи этих двух переменных была использована техника кодирования целочисленных SAT переменных OneHot+Binary~\cite{sat-encodings}: числовое значение переменной~$\ModularInputIndex{v}$ соответствует номеру входа~$u \in \SetAllInputs$, а биты соответствующего двоичного числа \--- значениям переменной $\InboundVarPinComputedValue{v,p}$.


\subsection{Сведение к SAT: ограничения}%
\label{sub:modular-arbitrary-constraints}

Для определения переменных $\InboundVarPinComputedValue{v,p}$ и $\OutboundVarPinComputedValue{v,p}$ объявляются следующие ограничения:
\begin{enumerate}[label=\arabic*)]
% DC: СТОИТ НАПИСАТЬ СЛОВАМИ, КАКАЯ ИМЕННО
\item Во-первых, учитывается взаимосвязь родителя контакта с его потомком:
\[
    \bigland{v \in \SetTreeNodes}
    \bigland{p \in \SetInboundVarPins}
    \left[
        \OutboundVarPinComputedValue{v,p}
        \iff
        \InboundVarPinComputedValue{v,\VarPinParent{p}}
    \right] .
\]

\item Во-вторых, учитываются начальные значения (\texttt{False}) всех выходных контактов:
\[
    \bigland{p \in \SetOutboundVarPins}
    \left[
        \OutboundVarPinComputedValue{1,p} = \bot
    \right] .
\]

\item В-третьих, учитываются значения входных переменных, записанные в вершинах дерева (кроме корня):
\[
    \bigland{v \in \SetTreeNodes \setminus \Set{\TreeRoot}}
    \bigland{p \in \SetExternalOutboundVarPins}
    \left[
        \OutboundVarPinComputedValue{v,p} = \tiv{v,\funcname{pinToInputVar}(p)}
    \right] ,
\]
где $\funcname{pinToInputVar}$ \--- функция, возвращающая входную переменную $x \in \SetInputVariables$, соответствующую внешнему выходному контакту $p \in \SetExternalOutboundVarPins$.

\item В-четвертых, значения входных контактов, у которых нет родителей, принимаются равными \texttt{False}:
\[
    \bigland{p \in \SetInboundVarPins}
    \left[
        (\VarPinParent{p} = 0)
        \implies
        \bigland{v \in \SetTreeNodes}
        (\InboundVarPinComputedValue{v,p} = \bot)
    \right] .
\]
\end{enumerate}

При отображении активных вершин дерева сценариев на состояния модулей необходимо учитывать нововведенную переменную~$\ModularInputIndex{}$:
\[
    \bigland{m \in \Modules}
    \bigland{v \in \SetTreeNodes}
    \left[
        (\ModularMapping{v} = q)
        \implies
        (\ModularActualTransitionFunction{q',u} = q)
    \right] ,
\]
где $p = \tp{v}$, $q' = \ModularMapping{p}$, $u = \ModularInputIndex{v}$.

Вычисляемые значения выходных контактов модулей зависят от своих предыдущих значений и определяются с помощью алгоритмов в состояниях модулей:
\[
    \bigland{m \in \Modules}
    \bigland{v \in \SetTreeNodes}
    \bigland{p \in \SetOutboundVarPins}
    \bigland{z \in \SetOutputVariables}
    \left[
        \OutboundVarPinComputedValue{v,p}
        \iff
        \fun{ITE}(\OutboundVarPinComputedValue{v',p}, \ModularStateAlgorithm{q,z,\top}, \ModularStateAlgorithm{q,z,\bot})
    \right] ,
\]
где $v' = \tp{v}$, $q = \ModularMapping{v}$.
Также необходимо ограничить значения внешних входных контактов (напомним, что эти контакты соответствуют выходным переменным внешнего модульного автомата) в соответствии со значениями в дереве сценариев:
\[
    \bigland{v \in \SetTreeNodes}
    \bigland{p \in \SetExternalInboundVarPins}
    \left[
        \InboundVarPinComputedValue{v,p} = \tov{v, \funcname{pinToOutputVar}(p)}
    \right] ,
\]
где $\funcname{pinToOutputVar}(p)$ \--- функция, возвращающая выходную переменную $z \in \SetOutputVariables$, соответствующую внешнему входному контакту $p \in \SetExternalInboundVarPins$.

% DC: Кстати, в общем случае это, вероятно, не так. Некоторые модули могут что-то делать. Нам достаточно потребовать, что на выход не передается события, а переменные не изменяют своих значений. Можно также упомянуть про это и указать, что мы сейчас используем такое упрощение.
При отображении пассивных вершин достаточно закодировать тот факт, что все модули игнорируют входное действие, записанное в вершине дерева сценариев. При этом необходимо учесть нововведенную переменную~$\ModularInputIndex{}$:
\[
    \bigland{m \in \Modules}
    \bigland{v \in \SetTreeNodesPassive}
    \left[
        (\ModularMapping{v} = \ModularMapping{\tp{v}})
        \land
        (\ModularActualTransitionFunction{q',u} = 0)
    \right] ,
\]
где $q' = \ModularMapping{\tp{v}}$, $u = \ModularInputIndex{v}$
Также, значения выходных контактов не изменяются, так как модули не генерируют выходных событий:
\[
    \bigland{v \in \SetTreeNodesPassive}
    \bigland{p \in \SetOutboundVarPins}
    \left[
        \OutboundVarPinComputedValue{v,p} = \OutboundVarPinComputedValue{\tp{v},p}
    \right] .
\]


\subsection{Алгоритмы \AlgoModularArbitraryBasic\ и \AlgoModularArbitraryExtended}%
\label{sub:algorithm-modular-arbitrary-basic-and-extended}

Аналогично разделу~\ref{sub:algorithm-modular-parallel-basic-and-extended}, обозначим $\AlgoModularArbitraryBasicFull(\SetPositiveScenarios, M, C, T)$ алгоритм, реализующий синтез модульной модели с \emph{произвольной} композицией модулей.
Также введем обозначение $\AlgoModularArbitraryBasic(\SetPositiveScenarios, M, C) =\allowbreak \AlgoModularArbitraryBasicFull(\SetPositiveScenarios, M, C, T=\infty)$.
В соответствии с разделом~\ref{sub:algorithm-modular-parallel-basic-and-extended}, алгоритм для синтеза расширенных моделей объявляется без пояснений:
\resizebox{.99\hsize}{!}{$\AlgoModularArbitraryExtended(\SetPositiveScenarios, M, C, P) = \AlgoModularArbitraryExtendedFull(\SetPositiveScenarios, M, C, P, N=\infty)$}.


% \subfile{tex/sec-modular-minimal}
\section{Синтез минимальных модульных моделей}%
\label{sec:modular-minimal}

% В этом разделе рассматривается итеративный подход к синтезу минимальных модульных моделей, аналогичный рассмотренному в разделе~\ref{sec:monolith-minimal}.

Для синтеза \emph{минимальных} модульных моделей в данной работе используется тот же итеративный подход, что и при монолитном синтезе (раздел~\ref{sec:monolith-minimal}).

Алгоритм $\AlgoModularParallelBasicMin(\SetPositiveScenarios, M)$ позволяет синтезировать базовую конечно-автоматную модель композитного функционального блока с параллельной композицией заданного числа модулей $M$ с минимальным числом состояний и переходов.
При минимизации предполагается, что все модули имеют одинаковое число состояний, а число переходов считается суммарно во всех модулях.
Возможно также рассмотрение такой постановки задачи, когда размеры каждого модуля заданы явно (или в виде некоторых интервальных оценок), однако в общем случае эти значения абсолютно неизвестны заранее.
В результате минимальная модульная модель содержит $M \cdot \Cmin$ состояний (по $\Cmin$ в каждом модуле) и $\Tmin = \Tmin^{(1)} + \dotsb + \Tmin^{(M)}$ переходов.
Здесь стоит отметить, что используемая нотация $\Tmin^{(m)}$ обозначает \emph{возможно неминимальное} число переходов в модуле $m \in \Modules$, входящего в состав \emph{минимальной} модульной модели с \emph{минимальным} суммарным числом переходов~$\Tmin$.

Аналогично, алгоритм $\AlgoModularParallelExtendedMin(\SetPositiveScenarios, M, P)$ позволяет синтезировать расширенную модульную модель с параллельной композицией $M$ модулей с минимальным числом состояний $M \cdot \Cmin$, минимальным суммарным размером охранных условий $\Nmin$ и максимальным размером каждого охранного условия~$P$.

Аналогичным образом определяются алгоритмы для синтеза базовых и расширенных модульных моделей с последовательной и произвольной композиций модулей:
\begin{itemize}[nosep]
    \item $\AlgoModularConsecutiveBasicMin(\SetPositiveScenarios, M)$: базовая/последовательная;
    \item $\AlgoModularConsecutiveExtendedMin(\SetPositiveScenarios, M, P)$: \rlap{расширенная/последовательная;}
    \item $\AlgoModularArbitraryBasicMin(\SetPositiveScenarios, M)$: базовая/произвольная;
    \item $\AlgoModularArbitraryExtendedMin(\SetPositiveScenarios, M, P)$: расширенная/произвольная.
\end{itemize}
% \begin{itemize}[nosep]
%     \item $\AlgoModularConsecutiveBasicMin(\SetPositiveScenarios, M)$: \\ синтез базовой модели с последовательной композицией;
%     \item $\AlgoModularConsecutiveExtendedMin(\SetPositiveScenarios, M, P)$: \\ синтез расширенной модели с последовательной композицией;
%     \item $\AlgoModularArbitraryBasicMin(\SetPositiveScenarios, M)$: \\ синтез базовой модели с произвольной композицией;
%     \item $\AlgoModularArbitraryExtendedMin(\SetPositiveScenarios, M, P)$: \\ синтез расширенная модели с произвольной композицией.
% \end{itemize}


% \subfile{tex/sec-exp-modular}
\section{Экспериментальное исследование: модульный синтез}%
\label{sec:experiments-modular}

% DC: В ВЫВОДАХ МОЖНО ДОПИСАТЬ, ЧТО ДЛЯ УСКОРЕНИЯ МЕТОДОВ ИЗ ТАБЛИЦЫ 4 МОГУТ ПОТРЕБОВАТЬСЯ ДОПОЛНИТЕЛЬНЫЕ СИММЕТРИ БРЕЙКИНГИ

% Here goes text

В данном разделе приводится экспериментальное исследование, посвященное применению разработанных методов для синтеза модульных конечно-автоматных моделей логических контроллеров с различными композициями модулей, входящих в состав композитного функционального блока: (1)~параллельной, (2)~последовательной и (3)~произвольной.
В качестве примера была использована система PnP\-/манипулятора, уже рассмотренная ранее в разделе~\ref{sec:experiments-monolith-pnp}.
% Система PnP\-манипулятора была рассмотрена ранее, в разделе~\ref{sec:experiments-monolith-pnp}, в контексте монолитного синтеза.
Несмотря на то, что исходная модель контроллера PnP\-/манипулятора является монолитной, модульный синтез позволяет синтезировать распределенную систему, реализующую схожее поведение.

Стоит отметить, что приведенное экспериментальное исследование не включает в себя сравнение с существующими методами, так как двухэтапный метод \enquote{Two-stage}~\cite{chivilikhin-19}, использованный в главе~\ref{ch:monolith-synthesis} неприменим к задаче модульного синтеза, а среди доступных инструментов для задачи модульного синтеза можно выделить только EFSM-tools~\cite{efsm-tools}, однако данное решение обладает следующими недостатками: (1)~низкая эффективность (по критериям времени работы и размерам моделей) на задаче монолитного синтеза, что подтверждено в~\cite{chivilikhin-19}, (2)~модульное разбиение должно быть известно заранее, так как его необходимо указывать вручную, в то время как разработанные в данной работе методы позволяют получать модульное разбиение автоматически.

В первом эксперименте были использованы методы для синтеза \emph{базовой} модульной модели, состоящей из двух модулей: $M = 2$.
В качестве входных данных были использованы наборы сценариев $\SetScenarios^{(1)}$, $\SetScenarios^{(4)}$ и $\SetScenarios^{(39)}$, где верхний индекс означает число сценариев в наборе.
В экспериментальном сравнении были использованы алгоритмы $\AlgoModularParallelBasicMin$, $\AlgoModularConsecutiveBasicMin$ и $\AlgoModularArbitraryBasicMin$.
Результаты первого эксперимента представлены в таблице~\ref{tab:results-modular-basicmin}, где
$\SetPositiveScenarios$ \=== набор сценариев выполнения,
$\card{\PositiveTree}$ \=== размер дерева сценариев,
$\Cmin$ \=== минимальное число состояний (одинаковые значения для каждого модуля),
$\Tmin$ \=== минимальное число переходов (указаны по-отдельности для каждого модуля: $\Tmin^{(1)}$+$\Tmin^{(2)}$),
\enquote{Время, с} \--- время работы в секундах.
Полученные результаты показывают, что методы синтеза минимальных модульных моделей с параллельной и последовательной композициями модулей обладают хорошей мастшабируемостью \--- время работы на большом наборе сценариев $\SetScenarios^{(39)}$ можно субъективно считать небольшим.
Что же касается произвольной композиции \--- результаты показывают, что эта задача является непростой и плохо мастабируется с ростом размера сценариев.
% однако стоит отметить, что б\'{о}льшую часть времени занимает именно процесс минимизации модели, а первое решение (неоптимальная модель) находится сравнительно быстро: результаты не приводятся, но для справки для $\SetScenarios^{(39)}$ время синтеза начальной модели порядка 200 секунд.
Низкую эффективность метода синтеза с произвольной композицией можно объяснить тем, что сведение (формула в КНФ для SAT-решателя) получается значительных размеров (для $\SetScenarios^{(39)}$ $\approx 2.5$~миллиона переменных, $\approx 45$~миллионов дизъюнктов), что соответствует большому пространству поиска, перебираемому в процессе минимизации.
В таких случаях обычно используются техники нарушения симметри (помимо уже рассмотренных в разделах~\ref{sub:encoding-bfs-automaton} и~\ref{sub:encoding-bfs-guards} BFS\-/предикатов нарушения симметрии), однако в данной работе их исследование и разработка не проводились.

%% Table: Results for Modular-*-BasicMin
\begin{table}[htb]
    \caption{Результаты синтеза базовых модульных конечно-автоматных моделей логического контроллера PnP-манипулятора}%
    \label{tab:results-modular-basicmin}
    \subfile{tex/tab-modular-basicmin-results}
\end{table}

%% Table: Results for Modular-*-ExtendedMin
\begin{table}[htb]
    \caption{Результаты синтеза расширенных модульных конечно-автоматных моделей логического контроллера PnP-манипулятора}%
    \label{tab:results-modular-extmin}
    \subfile{tex/tab-modular-extmin-results}
\end{table}

Аналогичным образом было проведено экспериментальное исследование методов синтеза \emph{расширенных} модульных моделей, охранные условия которых представлены в виде явных произвольных булевых формул.
При синтезе были использованы заранее выбранные значения параметра~$P$.
% без использования автоматизированного подбора оптимального значения, как это производится в алгоритме $\AlgoExtendedMinUB$.
% Данное допущение обусловлено тем, что это достаточно сложно реализовать, да и результаты были бы ЕЩЁ хуже.
В экспериментальном сравнении были использованы алгоритмы $\AlgoModularParallelExtendedMin$ и $\AlgoModularConsecutiveExtendedMin$.
Алгоритм $\AlgoModularArbitraryExtendedMin$ не был рассмотрен, так как задача синтеза расширенной модели значительно сложнее синтеза базовой, а алгоритм $\AlgoModularArbitraryBasicMin$ показал крайне низкую эффективность в предыдущем эксперименте.
Результаты второго эксперимента представлены в таблице~\ref{tab:results-modular-extmin}, где
$\SetPositiveScenarios$ \=== набор сценариев выполнения,
$\card{\PositiveTree}$ \=== размер дерева сценариев,
$\Cmin$ \=== минимальное число состояний в каждом модуле (одинаковые значения для каждого модуля),
$P$ \=== максимальный размер охранного условия,
$T$ \=== число переходов (не было минимизировано) (указаны по-отдельности для каждого модуля: \mbox{$T^{(1)}$+$T^{(2)}$}),
$\Nmin$ \=== минимальный суммарный размер охранных условий (указаны по-отдельности для каждого модуля: $\Nmin^{(1)}$+$\Nmin^{(2)}$),
\enquote{Время, с} \=== время работы в секундах.

Анализируя полученные результаты, можно прийти к выводу, что разработанные методы синтеза расширенных модульных моделей работают корректно, однако в целом неэффективно.
Можно заметить, что в случае параллельной и произвольной композиций основным результатом методов синтеза базовых моделей являются не сами модели, а модульное разбиение \--- соответствие переменных модулям, которые ими управляют.
При переходе к синтезу расширенной модели уже полученное модульное разбиение может быть зафиксировано, что положительно скажется на скорости решения ввиду того, что пространство поиска будет меньше, однако финальная модель в общем случае уже не будет минимальной.


\vspace{3ex}
\chapterconclusion

В данной главе была рассмотрена и решена задача синтеза минимальных конечно-автоматных моделей модульных логических контроллеров с различными видами композиции модулей: (1)~параллельной, (2)~последовательной и (3)~произвольной.
Разработанные методы были проверены в ходе экспериментального исследования, посвященного синтезу конечно-автоматной модели контроллера Pick-and-Place манипулятора.
Реализация методов включена в разработанное программное средство \smallcaps{fbSAT}~\cite{fbSAT-tool}.

% \nopagebreak\vspace{3ex}
% \printfleuron
