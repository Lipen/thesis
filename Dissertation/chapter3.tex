\chapter{Методы оценивания декомпозиционной трудности булевых формул в применении к задачам тестирования и верификации логических схем}
\label{ch:decompositions}

ICCAD/SAT/IEEE article

\section{Общие стратегии декомпозиции булевых формул, кодирующих задачи верификации (проверки эквивалентности) логических схем}

\todo{Основной вывод: нужно объединять "входы" схем, чтобы уменьшить размерность пространства поиска, а также чтобы получить меньшую дисперсию подзадач.}

Для эффективного решения сложных экземпляров SAT часто разумно использовать некоторые техники разделения исходной проблемы на более простые.
% TODO: fix "partitioning" translation
Естественным способом декомпозиции экземпляра SAT на подзадачи является так называемый \textit{подход к разбиению} (\textit{partitioning approach})~\cite{hyvarinen2011}.

Рассмотрим произвольную КНФ-формулу~$C$ над множеством булевых переменных~$X$ и множество $\Pi = \{G_1, \dots, G_s\}$, где $G_i$, $i \in\nobreak \{1, \dots, s\}$, представляют собой некоторые булевы формулы над~$X$.
Пусть $\Pi$ задает \textit{разбиение}~$C$, если выполняются следующие условия:
\begin{enumerate}
    \item формулы $C$ и $C \land (G_1 \lor \dots \lor G_s)$ равновыполнимы (\textit{equisatisfiable});
    \item для всех $i \neg j \in \{1, \dots, s\}$ формула $C \land G_i \land G_j$ выполнима.
\end{enumerate}

Здесь и далее будем называть конъюнкцию произвольных литералов (без эквивалентных и контрарных литералов) из~$X$ как \textit{куб} над~$X$.
Для произвольной КНФ~$C$ над переменными~$X$ простым примером разбиения является множество $\Pi = \{G_1, \dots, G_{2^r}\}$, которое состоит из всех возможных различных кубов размера~$r$ над множеством~$B$, где $|B| = r$.

\todo{Описать различные стратегии разбиения: по переменным (входы / (не-)балансные гейты), по кубам (CnC?), по чанкам (объединение входов), по интервалам.}


\section{Конструкции разбиения формул, кодирующих задачи верификации логических схем}

\todo{Чанки, балансные переменные, интервалы, математические свойства, детали программной реализации ("простая" реализация, BDD).}


% \section{Два новых построения SAT-разбиений для LEC}

Рассмотрим LEC для двух булевых схем $S_f$, $S_h$, определяющих функции $f, h \colon \{0,1\}^n \to \{0,1\}^m$.
Давайте сконструируем схему, полученную из $S_f$ и $S_h$ путем \enquote{склеивания} входных вершин (см.~Рис.~\ref{fig:glued}), и обозначим ее через $S_{f \glue h}$.
Она имеет такое же $\Vin$, как и $S_f$ и $S_h$, и определяет следующую функцию:
\begin{equation}\label{eq:f-glue-h}
    f \glue h \colon \{0,1\}^n \to \{0,1\}^{2m}
\end{equation}
Обозначим $\Vout_f$ и $\Vout_h$ множества выходов схем $S_f$ и $S_h$, а также через $Y_f = \{y_1^f, \dots, y_m^f\}$ и $Y_h = \{y_1^h, \dots, y_m^h\}$ множества переменных, ассоциированных с вершинами из $\Vout_f$ и $\Vout_h$ соответственно, упорядоченные в соответствии с семантикой схем.
Теперь рассмотрим формулу $(y_1^f \xor y_1^h) \lor \dots \lor (y_m^f \xor y_m^h)$, которая определяет булеву функцию $\mathcal{M} \colon \{0, 1\}^{2m} \to \{0, 1\}$, называемую \textit{miter}~\cite{brand1983}.
Применим к этой формуле преобразования Цейтина и обозначим полученную КНФ как $C(\mathcal{M})$.
Прямо следует из Леммы~\ref{lem1}, что схемы $S_f$ и $S_h$ эквивалентны тогда и только тогда, когда следующая КНФ-формула выполнима:
\begin{equation}\label{eq:miter-cnf}
    C_{f \glue h} \land C(\mathcal{M}) ,
\end{equation}
где $C_{f \glue h}$ является шаблонной КНФ для функции~\eqref{eq:f-glue-h}.

\begin{figure}
    \centering
    \begin{adjustbox}{max width=\linewidth}
        \subfile{tex/tikz-glued}%
    \end{adjustbox}
    \caption{Склеенная схема $S_{f \glue h}$, построенная с использованием одного и того же набора входов для двух схем $S_f$ и $S_h$}
    \label{fig:glued}
\end{figure}

Далее приведены две различные конструкции для эффективного построения SAT-разбиений для произвольного экземпляра задачи LEC.
Первую конструкцию определим следующим образом:
\begin{construction}\label{con1}
    Рассмотрим множество переменных $\Xin = \{x_1, \dots, x_n\}$, ассоциированных с входами схем $S_f, S_h, S_{f \glue h}$.
    Затем выберем целое число~$k$ так, что $1 < k < n$, и разобьем~$\Xin$ на~$q = \lceil n / k \rceil$ попарно непересекающихся множеств~$X^j$, где $j \in \{1, \dots, q\}$.
    Если $n$ делится на~$k$, то каждое множество~$X^j$ содержит $k$ переменных.
    В противном случае разобьем~$\Xin$ на $q-1$ множеств $X^1, \dots, X^{q-1}$ размером~$k$ каждое и одно множество~$X^q$ размером~$r$, такое что $n = k \cdot \lfloor \frac{n}{k} \rfloor + r$, где $r \in \{1, \dots, k-1\}$.
\end{construction}

Рассмотрим произвольную булеву функцию $\lambda \colon \{0,1\}^l \to \{0,1\}$, где~$l \in \Natural^{+}$, и предположим, что $\lambda$ не является константой.
Пусть $\neg\lambda \colon \{0,1\}^l \to \{0,1\}$ обозначает отрицание~$\lambda$.
С каждым~$X^j$, $j \in \{1, \dots, q\}$, свяжем две КНФ-формулы $\phi_1^j$ и $\phi_2^j$, которые определяют функции $\lambda^j \colon \{0,1\}^{|X^j|} \to \{0,1\}$ и $\neg\lambda^j \colon \{0,1\}^{|X^j|} \to \{0,1\}$ соответственно.

\begin{theorem}\label{thm:partitioning-input-decomposition}
    Пусть $\phi^j$ обозначает обе формулы $\phi^j_1$ и $\phi^j_2$.
    Множество~$\Pi$ всех $2^{\lceil n/k \rceil}$ возможных формул вида $\phi^1 \land \dots \land \phi^{\lceil n/k \rceil}$ формирует SAT-разбиение формулы~\eqref{eq:miter-cnf}.
\end{theorem}

\begin{proof}[Набросок доказательства]
    В доказательстве мы можем использовать Лемму~\ref{lem1}, чтобы показать, что любое присваивание, удовлетворяющее $C_{f \Delta h}$, также удовлетворяет ровно одной формуле вида $G_i \land C_{f \Delta h}$, где $G_i$, $i\in \{1,\dots,2^{\lceil n/k \rceil} \}$, является конкретным примером формулы $\phi^1 \land \dots \land \phi^{\lceil n/k \rceil}$ для определенных $\phi_l^j$, $l \in \{1,2\}$, $j \in \{1, \dots, 2^{\lceil n/k \rceil}\}$.
    Таким образом, формулы $C_{f \glue h} \land C(\mathcal{M})$ и $C_{f \glue h} \land C(\mathcal{M}) \land (G_1 \lor \dots \lor G_{2^{\lceil n/k \rceil}})$ равновыполнимы.
\end{proof}

Важным вопросом является выбор функций $\lambda^j$ и $\neg\lambda^j$ таким образом, чтобы гарантировать малую дисперсию $\fun{Var}(\xi_\Pi)$ для SAT-разбиения $\Pi$ описанного выше типа.
Здравый смысл подсказывает, что \emph{сбалансированная} булева функция, которая принимает значение 1 на $2^{l-1}$ входных словах, должна использоваться в качестве функции $\lambda \colon \{0,1\}^l \to \{0,1\}$.
Очевидно, что если $\lambda$ является сбалансированной функцией, то ее отрицание $\neg\lambda$ также является сбалансированной.
Хорошим примером сбалансированной функции для $l > 1$ является функция, заданная формулой $x_1 \xor \dots \xor x_l$.

В данной статье мы представляем немного неформальный анализ свойств Конструкции~\ref{con1} и используем его в качестве основы для Конструкции~\ref{con2}, которая показала лучшие результаты среди всех рассматриваемых методов в экспериментах с некоторыми чрезвычайно сложными экземплярами LEC в SAT-форме.
Рассмотрим функцию~\eqref{eq:f-glue-h} и шаблонную КНФ~$C_{f \glue h}$.
Множество экспериментов показывает, что даже когда SAT для~$C_{f \glue h} \land C(\mathcal{M})$ является крайне сложным, SAT для~$C_{f \glue h}$ остается простым: любой SAT-решатель на основе CDCL, получивший на вход $C_{f \glue h}$ без дополнительной информации о структуре схемы, умеет находить удовлетворяющее присваивание для~$C_{f \glue h}$.
Это присваивание можно рассматривать как удовлетворяющий сертификат для~$C_{f \glue h}$.
Как было отмечено выше, КНФ $C_{f\Delta h}$ имеет $2^n$ таких сертификатов.
Следовательно, доказательство невыполнимости $C_{f \glue h} \land C(\mathcal{M})$ можно рассматривать как процесс, который аннулирует все эти сертификаты.
Более того, если функции $\lambda^j$ сбалансированы для каждого $j \in \{1, \dots, \lceil n/k \rceil\}$, то каждая формула вида $\phi^1 \land \dots \land \phi^{\lceil n/k \rceil} \land C_{f \glue h}$ имеет $2^{n-\lceil n/k \rceil}$ удовлетворяющих присваиваний, которые также являются сертификатами удовлетворимости.
Таким образом, можно сделать два спекулятивных предположения:
\begin{enumerate}
    \item Для алгоритма $A$ намного проще доказать невыполнимость формулы $\phi^1 \land \dots \land \phi^{\lceil n/k \rceil} \land C_{f \glue h} \land C(\mathcal{M})$, потому что ему необходимо аннулировать $2^{n-\lceil n/k \rceil}$ сертификатов вместо $2^n$.
    \item Для сбалансированных функций $\lambda^{j}$, $j \in \{1, \dots, \lceil n/k \rceil\}$, все $2^{\lceil n/k \rceil}$ различных формул вида $\phi^1 \land \dots \land \phi^{\lceil n/k \rceil} \land C_{f \glue h} \land C(\mathcal{M})$ должны быть более или менее схожими по времени выполнения алгоритма $A$ на них, т.е. разбиение~$\Pi$, заданное Конструкцией~\ref{con1}, должно иметь малую дисперсию $\fun{Var}(\xi_{\Pi})$.
\end{enumerate}

Хотя представленные аргументы лишены строго формального доказательства, их выводы были экспериментально проверены.
Ниже мы опишем еще одну конструкцию, при разработке которой мы учитывали вышеуказанные свойства.

Основная идея описанной ниже конструкции заключается в том, чтобы рассмотреть произвольное присваивание переменных из $\Xin =\{x_1,\ldots,x_n\}$ как коэффициенты двоичного представления числа из $N_{0}^{n} = \{0,1,\ldots,2^n-1\}$.
Таким образом, существует взаимно однозначное соответствие $\{0,1\}^n \to N_{0}^{n}$.
Для произвольных $a,b \in N_{0}^{n}$ назовем множество чисел $\Set{ q \in N_{0}^{n} \given a \leq q \leq b }$ \textit{интервалом} и обозначим такой интервал как~$[a,b]$.
Рассмотрим множество булевых векторов из $\{0,1\}^n$, которые являются двоичными представлениями чисел из~$[a,b]$, как множество решений следующего целочисленного неравенства, предполагая, что $x_i$, $i \in \{1,\dots,n\}$ принимают значения из~$\{0,1\}$:
\begin{equation}\label{eq-ineq}
    a \leq x_1 + 2\cdot x_2 + \dots + 2^{n-1} \cdot x_n \leq b
\end{equation}
Пусть множество $\mathcal{R}^n$ состоит из интервалов описанного вида и является \textit{полной системой интервалов}, если ни один из двух интервалов из $\mathcal{R}^n$ не пересекаются и любое число из $N_{0}^{n}$ принадлежит какому-либо интервалу в $\mathcal{R}^n$.
Это означает, что любая полная система интервалов индуцирует разбиение $\{0,1\}^n$ на непересекающиеся подмножества, образованные решениями соответствующих неравенств \eqref{eq-ineq}.

\begin{construction}\label{con2}
    Пусть $\mathcal{R}^n$ будет полной системой интервалов.
    С~произвольным интервалом $I = [a,b] \in \mathcal{R}^n$ свяжем неравенство вида~\eqref{eq-ineq} и КНФ~$C_I$, полученную путем преобразования~\eqref{eq-ineq} в эквивалентную (или равновыполнимую) КНФ с использованием соответствующих техник, например, которые описаны в \cite{een2006}.
    Определим разбиение $\Pi = \{C_I\}_{I \in \mathcal{R}^n}$.
\end{construction}

\begin{theorem}\label{thm3}
    Множество $\Pi = \{C_I\}_{I\in \mathcal{R}^n}$, полученное с использованием Конструкции~\ref{con2}, формирует SAT-разбиение формулы $C_{f\Delta h} \land C(\mathcal{M})$.
\end{theorem}


\section{Экспериментальное исследование}
% \section{Вероятностный и статистический анализ свойств предложенных разбиений}

\todo{Вычислительные эксперименты и их результаты}
\todo{Multipliers, Sorters, Cryptography}
\todo{Статистические оценки, результаты из IEEE, доверительные интервалы, обоснование мощности выборки}

\section{Вычислительные эксперименты}
\label{sec:experiments}

Все эксперименты, представленные в данном разделе, были проведены на кластере, где каждый узел оснащен двумя 18-ядерными процессорами Intel Xeon E5-2695~v4 и 128~ГБ оперативной памяти.
Мы использовали Kissat\footnote{\url{https://github.com/arminbiere/kissat}} (версия 3.0.0) в качестве нашего решателя SAT из-за его высокой производительности и возможностей настройки.
Хотя мы также тестировали другие решатели, Kissat продемонстрировал значительное превосходство на рассматриваемых тестовых наборах.
Это было согласовано даже при использовании подхода CnC с инкрементальными решателями (включая те, которые интегрированы в репозиторий CnC и последнюю версию Cadical).
Kissat выделялся при решении кубов на всех тестовых наборах и решателях.

Основным вопросом, который мы изучали в вычислительных экспериментах, была точность оценок сложности относительно разбиения (в смысле формулы~\eqref{def:hardness-wrt-part}).
Ситуации, когда сложность относительно разбиения меньше или близка к времени выполнения последовательного решателя SAT на исходной задаче, являются особенно интересными, потому что в таких случаях соответствующие разбиения позволяют не только точно оценить время выполнения решателя SAT на задаче (в отличие от случая последовательного решения), но и обеспечивают более эффективную стратегию решения соответствующего экземпляра LEC.

Все дополнительные материалы к настоящей статье доступны онлайн\footnote{\url{https://github.com/Lipen/FMCAD-2023-Supplementary}}.


\subsection{Тестовые данные}

Мы рассматриваем два класса тестовых наборов (бенчмарков).
Первый класс состоит из (невыполнимых) экземпляров задачи LEC для схем, представляющих алгоритмы умножения, такие как
\enquote{умножение столбиком}, \enquote{дерево Уоллеса}~\cite{cormen90}, \enquote{алгоритм Карацубы}~\cite{knuth1969} и \enquote{умножитель Дадда}~\cite{dadda1965}.
Эти экземпляры обозначаются как \instance{AvB}{k}, где \Instance{A} и \Instance{B} означают алгоритмы умножения, а $k$ \=== количество бит в умножаемых числах.
Например, \instance{CvK}{16} представляет собой экземпляр LEC для проверки эквивалентности умножения двух 16-битных чисел (\texttt{16x16} умножитель) методом столбика и алгоритмом Карацубы.
Такие бенчмарки известны своей сложностью для современных SAT-решателей~\cite{kaufmann2019,CP2021}.

Второй класс состоит из нескольких (выполнимых) экземпляров, связанных с алгебраическим криптоанализом~\cite{bard2009}, а именно, SAT-кодировок атаки прообраза на хеш-функцию MD4 с уменьшенным числом раундов.
Эта проблема была недавно решена в~\cite{DBLP:conf/ijcai/Zaikin2022} с использованием подхода Cube and Conquer.
Тестовые наборы MD4 служат дополнительным материалом для того, чтобы показать, что предложенная техника действительно применима к (1)~совместимым тестовым наборам (2)~наборам, которые не кодируют LEC.

\subsection{Эксперименты по оценке сложности}

В первом наборе экспериментов мы оцениваем сложность экземпляров LEC для умножителей относительно предложенных разбиений SAT, где мы разбиваем множество входов~$\Xin$ на непересекающиеся подмножества, называемые \emph{чанками}, в соответствии с Конструкцией~\ref{con1}.
Мы рассматриваем следующие виды функций~$\lambda^j$:
\begin{itemize}
    \item \Part{2-XOR}: $\lambda^1 = x_1 \xor x_2$, \Part{3-XOR}: $\lambda^1 = x_1 \xor x_2 \xor x_3$, \textit{и т.д.};
    \item \Part{2-DIS}: $\lambda^1 = x_1 \lor x_2$;
    \item \Part{3-MAJ}: $\lambda^1 = \fun{majority}(x_1, x_2, x_3)$, где $\fun{majority}(a, b, c) = (a \land b) \lor (a \land c) \lor (b \land c)$;
\end{itemize}
Функции $\lambda^j$ для $j > 1$ определены на соответствующих непересекающихся чанках входов, например, $\lambda^2 = x_4 \xor x_5 \xor x_6$ для \Part{3-XOR}.
Во всех случаях формулы, соответствующие $\lambda_1^j = \lambda^j$ и $\lambda_2^j = \neg\lambda^j$, были закодированы в~CNF.

Аналогично, для разбиений SAT, построенных в соответствии с Конструкцией~\ref{con2}, мы используем обозначение \Part{INT-s}, где $s$~обозначает количество интервалов, например, \Part{INT-65536} соответствует разбиению на \np{65536} подзадач.

Чтобы обеспечить достоверность и актуальность наших результатов, среди всех составленных бенчмарков были выбраны только те экземпляры, которые представляют практический интерес, то есть те, которые не решаются в течение нескольких секунд, но могут быть решены за разумное время.
Для тестовых наборов алгоритмов сортировки были выбраны экземпляры, которые кодируют LEC для $k = 9$ и~$l = 4$.
Среди умножителей были выбраны экземпляры двух разных уровней сложности (умножители \texttt{12x12} и \texttt{16x16}, например, \instance{CvK}{12} или \instance{KvW}{16}) для демонстрации гибкости нашего подхода в решении задач с различной сложностью.
Для каждого выбранного экземпляра были построены соответствующие разбиения и были решены \textbf{все} подзадачи, чтобы вычислить истинные значения математического ожидания~$\E[\xi_\Pi]$ и дисперсии~$\fun{Var}(\xi_\Pi)$.

Кроме того, были рассмотрены разбиения, построенные с использованием техники Cube and Conquer (CnC).
Для этой цели были построены кубы с помощью \texttt{march\_cu}\footnote{\url{https://github.com/marijnheule/CnC}}.
В частности, были подобраны значения опций \texttt{-d <depth>} и \texttt{-n <number>} таким образом, чтобы размеры полученных разбиений были аналогичны разбиению, построенному с помощью методов, предложенных в данной работе.
Для некоторых \enquote{простых} экземпляров также был запущен \texttt{march\_cu} с параметрами по умолчанию, которые могут рассматриваться как базовый уровень в этом экспериментальном исследовании.
Однако для некоторых \enquote{более сложных} экземпляров режим по умолчанию не смог выдать результаты (т.е. набор кубов) за разумное время (24~часа), что привело к пропуску этих экспериментов.
Затем все полученные кубы были независимо решены параллельно.
Далее в этом документе будем обозначать эти разбиения, сгенерированные CnC, как \Part{CnC-d*}, \Part{CnC-n*} и \Part{CnC-default}.

Экспериментальные результаты суммируются на Рисунках \ref{fig:ridges}~и~\ref{tab:results-partitionings-best}.
В частности, Рисунок~\ref{fig:ridges} содержит
подробные результаты для \textit{всех} обсуждаемых типов разбиений на двух выбранных экземплярах (\instance{CvK}{12} и \instance{CvK}{16}).
Тем временем, Рисунок~\ref{tab:results-partitionings-best} представляет \emph{лучшие} разбиения для остальных экземпляров.
Для каждого разбиения сообщается среднее и стандартное отклонение (\enquote{Avg~$\pm$~sd}), диапазон времени выполнения подзадач (\enquote{Min\,--\,max}) и общее CPU-время, необходимое для решения всех подзадач.
Таблица также включает строки \enquote{Sequential} для представления базовой производительности последовательного решателя SAT без применения разбиения на основе разбиения.

Графики на Рисунке~\ref{fig:ridges} визуализируют дисперсию времени выполнения SAT-решателя при использовании рассматриваемых схем разбиения.
Для конструкций \ref{con1}~и~\ref{con2} (разбиения \Part{2-XOR} и \Part{INT}, соотвественно) время выполнения SAT-решателя имеет относительно низкую дисперсию, что указывает на то, что мы можем точно оценить необходимое общее время выполнения, используя относительно небольшой объем выборки.
Напротив, для Cube and Conquer и разбиений \Part{2-DIS} дисперсия значительно больше из-за неравномерного распределения сложности подзадач.
Для последнего это можно объяснить дисбалансом функции $\lambda = a \lor b$, используемой в \Part{2-DIS}.
Эти результаты подчеркивают важность выбора подходящих схем разбиения для достижения более последовательной производительности времени выполнения и точной оценки общего времени выполнения.

Экспериментальные результаты показывают, что оценка для разбиения не всегда согласуется с временем выполнения последовательного решателя на исходной проблеме.
Интересно, что наши результаты показывают, что общее время, необходимое для решения всех подзадач для экземпляров умножителей, существенно меньше времени, необходимого для последовательного решения.
В частности, для 16-битных умножителей однопоточный решатель не смог завершить работу даже после 10 дней, в то время как все подзадачи в разложении были решены в разумное и \emph{предсказуемое} время, соответствующее оценке.
Для \enquote{Sequential} строки в таблицах следует уточнить, что решатель выполнялся на одном ядре, в то время как все остальные эксперименты вычислялись параллельно, и представленное общее время CPU является суммой времени выполнения на всех подзадачах.

В контексте всего сказанного одной из основных проблем является точность полученных оценок~$\E[\xi_\Pi]$.
Дисперсия~$\fun{Var}(\xi_\Pi)$ оказывает отрицательное влияние на точность.
Однако результаты в Таблице~\ref{tab:results-partitionings-best} показывают, что предложенные методы SAT-разбиения дают очень низкую дисперсию на рассматриваемых бенчмарках.
Это является значительным преимуществом предложенного метода, так как он позволяет использовать небольшую случайную выборку для получения надежной оценки~$\E[\xi_\Pi]$.
Для демонстрации этого мы выполняем дополнительный анализ полученных результатов.

Для различных значений~$N$ мы генерируем $P = 1000$ случайных выборок размера~$N$ и вычисляем средние значения выборок $(\hat{\xi}^1, \dots, \hat{\xi}^P)$, где каждое $\hat{\xi}^r = \frac{1}{N} \bigsumnolim{j=1}^{N} \xi_j^r$.
Мы также вычисляем среднее значение средних значений выборок $\Xi(N) = \frac{1}{P} \sum_{r=1}^{P} \hat{\xi}^r$ и минимальные и максимальные значения среди~$\hat{\xi}$, обозначенные $M_*(N)$~и~$M^*(N)$, соответственно.
Затем все значения нормализуются путем деления их на~$\E[\xi_\Pi]$.
Распределения нормализованных средних значений выборок для различных размеров выборки показаны на Рисунке~\ref{fig:min-max-CvK-16-kissat}, где горизонтальная ось представляет размер случайной выборки~$N$.
Здесь мы рассматриваем экземпляр LEC умножителей~\instance{CvK}{16} и два различных разбиения: \Part{INT-65536} (предложенное разбиение на \np{65536}~интервалов) и \Part{CnC-d16} (Cube and Conquer, используя \texttt{march\_cu -d 16}).
На графиках показаны нормализованные линии для минимальных и максимальных значений, представленных как $M_*(N) / \E[\xi_\Pi]$ (зеленая линия, внизу) и $M^*(N) / \E[\xi_\Pi]$ (оранжевая линия, сверху), соответственно.
Результаты показывают, что выборочное среднее~$\hat{\xi}$ является надежной оценкой~$\E[\xi_\Pi]$, даже когда $N$ гораздо меньше общего размера разбиения.
Например, размер выборки~$N \approx 30$ из общего числа \np{65536}~подзадач для разбиения \Part{INT-65536} в экземпляре~\instance{CvK}{16} достаточен для получения оценки в пределах 10\%\=/интервала~$\E[\xi_\Pi]$.
Наоборот, достаточный размер выборки для разбиений CnC обычно значительно больше, особенно для \Part{CnC-d16} (которое также имеет размер \np{65536}), он составляет как минимум $N \approx 1000$.
