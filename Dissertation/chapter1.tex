% \chapter{Базовые понятия и результаты}
\chapter{Обзор предметной области}
\label{ch:overview}

В данной главе представлены основные понятия и существующие результаты.


\section{Дискретные управляющие модели}
\label{sec:discrete-control-models}

Здесь описываются дискретные управляющие модели и их применение.

\subsection{Конечные автоматы}

Конечный автомат (КА) --- это модель вычислений, которая описывает систему с конечным числом состояний и переходов между ними.
Конечный автомат может быть задан в виде пятерки $\mathcal{A} = \Tuple{\Sigma, Q, q_0, F, \delta}$, где:
\begin{itemize}
    \item $\Sigma$ --- алфавит входных символов;
    \item $Q$ --- (\emph{конечное}) множество состояний;
    \item $q_0 \in Q$ --- начальное состояние;
    \item $F \subseteq Q$ --- множество терминальных (принимающих) состояний;
    \item $\delta \colon Q \times \Sigma \to Q$ --- функция переходов.
\end{itemize}
Конечный автомат \emph{принимает} (\textit{accepts}) слово $w = w_1 w_2 \ldots w_n \in \Sigma^*$, если после прочтения $w$ автомат оказывается в одном из терминальном состоянии $s_n \in F$, то есть существует последовательность состояний $s_0, s_1, \ldots, s_n$ такая, что $s_0 = q_0$, $s_{i+1} = \delta(s_i, w_{i+1})$ для всех $i \in \Set{0, 1, \ldots, n-1}$ и $s_n \in F$.


\subsection{Булевы схемы}

% Булева схема может быть задана в виде кортежа $\mathcal{C} = \Tuple{I, O, G, L}$, где:
% \todo{пофиксить кортеж}
% \begin{itemize}
%     \item $I$ --- множество входных вершин (\textit{inputs});
%     \item $O$ --- множество выходных вершин (\textit{outputs});
%     \item $G$ --- множество внутренних вершин (\textit{gates});
% % \item $W \subseteq I \union G$ --- множество входных вершин, которые не являются входами схемы (\textit{wires});
%     \item $L \colon G \to \Set{\land, \lor, \neg, \dots}$ --- функция, которая каждой внутренней вершине сопоставляет логическую функцию.
% \end{itemize}

Булева схема \--- это направленный ациклический ориентированный граф $G = \Pair{V, E}$, где $V$ \=== множество вершин, а $E \subseteq V^2$ \=== множество рёбер (\textit{дуг}).
Вершины такого графа делятся на три типа: входные вершины (\textit{inputs}), выходные вершины (\textit{outputs}) и внутренние вершины (\textit{gates}).
\textit{Ребро} (\textit{дуга}) представляет собой упорядоченную пару вершин.
Для каждой дуги $(u,v) \in E$, вершина $u$ называется \textit{родителем}~$v$, а $v$ \=== \textit{потомком} $u$.
Множество всех родителей вершины~$v$ обозначается как~$P_v$.
Вершина называется \textit{входной}, если у нее нет родителей, и \textit{выходной}, если у нее нет потомков\footnote{Здесь стоит учитывать, что вполне возможны вариации данных определений. В некоторых ситуациях \textit{входными}/\textit{выходными} вершинами в схеме считаются некоторые заранее выбранные вершины, но при этом у них могут быть родители/потомки, соотвественно. В зависимости от контекста, эти родители/потомки игнорируются в соответствующих определениях, связанных с обходом вершин графа от \textit{входов} к \textit{выходам}.}.
Множества входов и выходов обозначаются как $\Vin \subseteq V$ и $\Vout \subseteq V$ соответственно.
Любая вершина $v \in V \setminus \Vin$ называется \textit{гейтом} (\textit{логическим вентилем}).
В булевой схеме каждому гейту сопоставляется некоторый \textit{логический элемент} из предопределенного набора, называемого \textit{базисом} (например, $\{\land, \neg\}$).
Таким образом, любой логический элемент интерпретирует некоторую элементарную булеву функцию.
Пример булевой схемы представлен на Рисунке~\ref{fig:boolean-circuit-example}.

\begin{figure}[ht]
    \centering
    % \includegraphics[max width=0.5\textwidth]{example-image}
    \begin{adjustbox}{max width=\linewidth}
        \subfile{tex/tikz-circuit-example}
    \end{adjustbox}%
    \caption{Пример булевой схемы с тремя входами ($i_1$,~$i_2$,~$i_3$) и восьмью гейтами}
    \label{fig:boolean-circuit-example}
\end{figure}

Булева схема с $n$~входами и $m$~выходами естественным образом задает (тотальную) дискретную функцию $f \colon \{0, 1\}^n \to \{0, 1\}^m$, где под $\{0,1\}^k$ мы понимаем множество всех возможных двоичных слов длины~$k \in \Natural^{+}$.
Имея это в виду, мы будем использовать обозначение~$S_f$ для представления булевой схемы, задающей функцию~$f$.
Каждому гейту схемы $S_f$ сопоставлена булева функция, которая соответствует логическому элементу, назначенному этому гейту.

Пусть $\alpha\in\{0,1\}^n$ произвольное слово, поданное на вход~$S_f$.
Проходя по гейтам схемы в фиксированном порядке (обычно указанном топологической сортировкой~\cite{cormen90}) и вычисляя значения элементарных функций, сопоставленных гейтам, мы получаем значение функции~$f$ на входном слове~$\alpha$ в качестве результата.
Этот процесс называется \textit{интерпретацией} схемы~$S_f$ на входе~$\alpha$.

Каждой вершине в схеме~$S_f$ сопоставим булеву переменную.
Обозначим множество переменных, ассоциированных с входами $\Vin$ схемы~$S_f$, как $\Xin = \{x_1,\ldots,x_n\}$.
Переменные, связанные с гейтами, мы будем называть \textit{вспомогательными} (\textit{auxiliary}).
Пусть $u$ \=== некоторая вспомогательная переменная, соответствующая гейту~$v$, и $U_v$ \=== множество переменных, связанных с вершинами из~$P_v$.
Предположим, что $h_v$ \=== булева функция, соответствующая логическому элементу, назначенному гейту~$v$, и $F(h_v)$ \=== булева формула над~$U_v$, которая задает функцию~$h_v$.
Обозначим через $C_v$ КНФ-представление формулы $F(h_v) \equiv u$.

Рассмотрим следующую КНФ:
\begin{equation}\label{eq1}
    C_f = \biglandclap{v \in V \setminus \Vin} C_v
\end{equation}
Мы будем обозначать~\eqref{eq1} как \textit{шаблонную КНФ} для функции~$f$.
Заметим, что $C_f$~является КНФ-формулой, полученной применением преобразований Цейтина~\cite{tseitin1970} к схеме~$S_f$.

Ниже, следуя работе~\cite{szeider2006}, будем использовать обозначение~$x^{\sigma}$, где $\sigma \in \{0,1\}$, предполагая, что $x^0$ обозначает отрицательный литерал~$\neg x$, а $x^1$ обозначает положительный литерал~$x$, а также обозначение $\{0,1\}^{|B|}$, что означает множество всех возможных назначений переменных из~$B$.
%Пусть~$F$ будет произвольной булевой формулой над переменными~$X$.
%Обозначим через~$F|_{x=\sigma}$ формулу, полученную подстановкой~$x$ на место~$\sigma$ в~$F$~\cite{chang1973}.
%Очевидно, что формы $x^\sigma\land F$ и $F|_{x=\sigma}$ являются равноправными по удовлетворимости.
%Таким образом, когда мы работаем с формулой $x^\sigma \land F$, мы можем рассматривать единичную дизъюнкцию~$x^\sigma$ как значение~$\sigma$ переменной~$x$ в~$F$.
%Для произвольного набора булевых переменных~$B$ через $\{0,1\}^{|B|}$ мы обозначаем множество всех возможных назначений переменных из~$B$.
Следующий факт был многократно установлен в литературе, например, см.~\cite{bessiere2009,drechsler2009}.
Он использует простой механизм булевой дедукции, известный как правило распространения единичного дизъюнкта (Unit Propagation \--- UP)~\cite{marques-silva2009}.

\begin{lemma}\label{lem1}
    Применение UP к КНФ-формуле $x_1^{\alpha_1} \land \dots \land x_n^{\alpha_n} \land C_f$ для любого $\alpha = (\alpha_1, \dots, \alpha_n)$, $\alpha \in \{0,1\}^{|\Xin|}$ выводит (в форме единичных дизъюнкций) значения всех переменных, связанных с гейтами из $V \setminus \Vin$, включая переменные $y_1, \dots, y_m$, связанные с выходами схемы $S_{f}$: $y_1=\gamma_1, \dots, y_m=\gamma_m$, $f(\alpha) = \gamma = (\gamma_1, \dots, \gamma_m)$.
\end{lemma}

Стоит отметить, что Лемма~\ref{lem1} в сущности означает, что процесс интерпретации схемы~$S_f$ на входном слове~$\alpha$ может быть смоделирован последовательным применением UP к КНФ $x_1^{\alpha_1} \land \dots \land x_n^{\alpha_n} \land C_f$ для любого $\alpha = (\alpha_1, \dots, \alpha_n)$.
Лемма~\ref{lem1} очень полезна при доказательстве свойств, связанных с булевыми схемами и SAT.


\section{Задачи синтеза и верификации дискретных управляющих моделей}
\label{sec:synthesis-and-verification}

\subsection{Международный стандарт IEC~61499}%
\label{sub:iec61499}

% TODO: Здесь должно быть описание стандарта IEC~61499, функциональных блоков и так далее.

Международный стандарт распределенных систем управления и автоматизации IEC~61499~\cite{vyatkin-tii} нацелен на упрощение разработки распределенных киберфизических систем.
Стандарт отличается от \enquote{предыдущего} стандарта IEC~61131\cite{iec-61131} тем, что в IEC~61499 используется событийная модель исполнения.
Этот стандарт предлагает использование так называемых \emph{функциональных блоков} (ФБ), являющихся, по-сути, контейнерами для базовых элементов \--- управляющих конечных автоматов.
Основные типы описываемых в стандарте IEC~61499 функциональных блоков \--- \emph{базовые} и \emph{композитные}.
Функционал композитных блоков определяется сетью базовых ФБ.
Базовые ФБ являются совокупностью интерфейса (описания входных и выходных событий и переменных) и управляющего конечного автомата (\textit{Execution Control Chart} \--- ECC).
% Подробное описание формальной модели~\cite{dubinin-2006} базового функционого блока предоставлено в разделе~\ref{sec:basic-fb-model}.

% TODO: more?

\subsection{Методы синтеза конечно-автоматных моделей}
\label{sub:automata-synthesis}

% TODO: More intro here?

Задача поиска минимального детерминированного конечно автомата по примерам поведения является NP-полной задачей~\cite{gold}, а сложность задачи LTL-синтеза дважды экспоненциальная от размера LTL\-/спецификации.
Не смотря на это, синтез различных типов конечно-автоматных моделей по примерам поведения и/или формальной спецификации был исследован во многих научных работах~\cite{heule2010,efsm-tools,zakirzyanov2019,buzhinsky-tii,bosy,tsarev-egorov-gecco,giantamidis-tripakis,petrenko,petrenko2,neider,g4ltl-st,smetsers-lata}, где используются методы, основанные на эвристическом объединении состояний (\emph{state merging}), эволюционные алгоритмы, а также методы, основанные на применении SAT- и SMT-решателей.
В данной работе рассматриваются только точные и эффективные методы, поэтому внимание уделяется методам с применением SAT-решателей.

Расширенный конечный автомат (\emph{Extended Finite State Machine} \--- EFSM) является моделью, наиболее близкой к рассматриваемой в данной работе модели ECC\@. EFSM является объединением автомата Мили и Мура, расширенный условными переходами. Переходы в EFSM помечены входными событиями и охранными условиями \--- булевыми функциями от входных переменных, а состояния EFSM имеют ассоциированные выходные действия.
Для синтеза EFSM по примерам поведения и LTL\-/спецификации существует несколько подходов~\cite{efsm-tools,walkinshaw}, основанных на сведении к задаче SAT. В~\cite{efsm-tools} LTL\-/спецификация учитывается путём применения итеративного подхода запрета контрпримеров.
Существенным недостатком~\cite{efsm-tools} является то, что охранные условия должны быть известны заранее, а также то, что синтезируемые алгоритмы в состояниях EFSM являются лишь указаниями на некоторые внешние процедуры.
В~\cite{walkinshaw} решается задача синтеза вычислимых выходных алгоритмов, однако предполагается, что базовая модель автомата (то есть его структура \--- состояния и переходы между ними) известна заранее или получается отдельно.
В общем случае, при использовании исходных данных, получаемых при black-box тестировании системы, информация о внутреннем устройстве системы, а также о доступных внешних процедурах и их поведении, оказывается недоступной, поэтому существующие методы синтеза EFSM не подходят для решения задачи синтеза модели ECC, рассматриваемой в данной работе.

Программное средство BoSy~\cite{bosy,not-bosy} реализует так называемый ограниченный синтез (\emph{bounded synthesis}) системы переходов (\emph{transition system}) по LTL\-/спецификации. Синтез \enquote{ограничен} в том смысле, что позволяет синтезировать систему заданного размера, либо гарантировать отсутствие решения заданного размера.
В BoSy реализовано не только сведение задачи LTL-синтеза к SAT, но также разработано более эффективное (при рассмотренной авторами постановке задачи) сведение с использованием Quantified SAT (QSAT). При использовании SAT-кодировки, синтезируемые системы переходов являются \enquote{явными} (\emph{explicit}) \--- охранные условия на переходах являются полными зависят от всех входных переменных. При использовании QSAT-кодировки, системы получаются \enquote{символьными} (\emph{symbolic}) \--- охранные условия синтезируются в виде полноценных булевых формул.
\mbox{Используемые} в BoSy подход ограниченного синтеза позволяет синтезировать минимальные модели в терминах числа состояний, однако важный вопрос о размере охранных условий обходится стороной \--- синтезируемые модели, как правило, обладают огромными охранными условиями, что сильно затрудняет их восприятие человеком, а также ограничивает применимость таких моделей во встраиваемых системах.
В~\cite{bounded-cycle} предлагается способ упрощения генерируемых моделей, заключающийся в дополнении SAT сведения специальными ограничениями для минимизации числа циклов в системе переходов, однако это слабо влияет на размеры и форму охранных условий.
Также стоит упомянуть, что отличительной особенностью LTL-синтеза является то, что в качестве входных данных не используются примеры поведения, так как предполагается полнота входной спецификации \--- в том смысле, что она описывает все желаемое поведение системы.
Не смотря на то, что примеры поведения могут быть представлены в \mbox{виде} LTL-свойств, этот подход становится крайне неэффективным уже на небольших наборах данных.
Другие программные средства для LTL-синтеза, например G4LTL\=/ST~\cite{g4ltl-st} и Strix~\cite{strix}, обладают аналогичными недостатками по отношению к рассматриваемой задаче, а именно, отсутствие минимизации охранных условий и невозможность (эффективного) учета примеров поведения.

В статье~\cite{fbCSP} предлагается метод \smallcaps{fbCSP} для синтеза конечно-автоматных моделей функциональных блоков по примерам поведения, основанный на сведении к задаче удовлетворения ограничений (\textit{Constraint Satisfaction Problem} \--- CSP).
Однако методу \smallcaps{fbCSP} присущи следующие ограничения.
Получаемые модели обладают \emph{полными} охранными условиями \--- соответствующие булевы формулы зависят от \emph{всех} входных переменных.
Такие модели практически не обобщаются (\textit{generalize}), то есть некорректно работают на входных данных, которые не были использованы в процессе \enquote{обучения} (синтеза).
В~\cite{fbCSP} это отчасти исправляется дополнительной жадной минимизацией охранных условий, однако жадный подход не гарантирует, что охранные условия будут наименьшими.
В работе~\cite{chivilikhin-18} метод \smallcaps{fbCSP} был расширен процедурой запрета контрпримеров для учета LTL\-/спецификации (в дальнейшем это расширение будет называться \smallcaps{fbCSP+LTL}), аналогично работе~\cite{efsm-tools}.
При этом охранные условия в генерируемых моделях представляются в виде конъюнкции литералов входных переменных.
Основным недостатком этого подхода является его низкая эффективность в тех случаях, когда темпоральная спецификация покрыта сценариями выполнения не полностью.

В работе~\cite{chivilikhin-19} разработан двухэтапных подход:
сначала генерируется \emph{базовая} модель с использованием метода, основанного на SAT, а затем охранные условия полученной модели отдельно минимизируются с помощью CSP \--- деревья разбора булевых формул, соответствующих охранным условиям, кодируются в CSP, а затем минимизируется их суммарный размер.
Таким образом, получаемая модель является минимальной, однако независимость двух этапов приводит к тому, что модель не является наименьшей (в терминах суммарного размера охранных условий).

Резюмируя, ни один из рассмотренных методов, каждый из которых по своему хорош при конкретной постановке задачи, не позволяет \emph{одновременно} и \emph{эффективно} учитывать при синтезе конечно-автоматных моделей как (1)~примеры поведения, так и (2)~LTL\-/спецификацию, а также (3)~минимальность генерируемых моделей.
В ходе выполнения данной работы был разработан метод, который фактически является расширением~\cite{chivilikhin-19} \--- объединением двух независимых этапов в один \--- и вносит вклад в расширение \textit{state-of-the-art} конечно-автоматного синтеза с применением SAT-решателей, а именно: \emph{одновременно} поддерживает учет позитивных примеров поведения, реализует индуктивный синтез, основанный на контрпримерах \--- для учета LTL\-/спецификации, а также позволяет генерировать минимальные модели \--- как в терминах числа состояний, так и в терминах суммарного размера охранных условий.

\subsection{Верификация конечно-автоматных моделей}
\label{sub:automata-verification}

\subsection{Линейная темпоральная логика}%
\label{sub:ltl}

% TODO
% TODO
% TODO !
% TODO
% TODO
% TODO.
% Здесь должно быть описание LTL~\cite{ltl} и контрпримеров, получаемых с помощью NuSMV~\cite{NuSMV}. Негативные сценарии выполнения и соотвествующее дерево негативных сценариев описываются отдельно в разделе~\ref{sec:negative-scenarios}

Формальная спецификация может быть проверена с помощью верификатора (\emph{model checker}) \--- специализированного программного средства, которое проверяет выполнение заданных свойств в системе и генерирует контрпримеры к нарушенным свойствам.
В данной работе был использован символьный верификатор NuSMV~\cite{NuSMV}, а рассмотренные спецификация систем были составлены на языке линейной темпоральной логики (\textit{Linear Temporal Logic} \--- LTL)~\cite{ltl}, полностью поддерживаемом NuSMV\@.
Для так называемых \enquote{свойств безопасности} (\textit{safety properties}), выражающих отсутствие нежелательного поведения (например, \enquote{с системой никогда не произойдёт ничего плохого}), контрпримером является конечная последовательность вычислительных состояний (\textit{execution state}), приводящая к нежелательному поведению.
Для так называемых \enquote{свойств живости} (\textit{liveness properties}), выражающих присутствие желаемого поведения (например, \enquote{с системой точно произойдет что-то хорошее}), контрпримером является бесконечная, но циклическая последовательность состояний, представляющая нежелательное циклическое поведение системы, и которая может быть представлена в виде конечного префикса с последующим циклом конечной длины~\cite{clarke1999model}.



\subsection{Синтез булевых формул и схем}
\label{sub:circuits-synthesis}

\subsection{Верификация булевых схем}
\label{sub:circuits-verification}

Задачи LEC и ATPG.

% % TODO: do not use subsubsections
% \subsubsection{Задача проверки эквивалентности булевых схем}
% \label{subsub:lec}

% % TODO: do not use subsubsections
% \subsubsection{Задача генерации тестов для булевых схем}
% \label{subsub:atpg}

\subsection{Задача генерации тестовых шаблонов для верификации булевых схем}
\label{sub:atpg}

После производства микросхемы необходимо проверить ее функциональную корректность.
В противном случае продукты с неисправностями могут быть доставлены заказчикам, что недопустимо для любой компании.
Во время тестирования после производства на вход схемы подаются тестовые сигналы, и контролируется правильность выхода.
Эти входные сигналы называются \textit{тестовыми шаблонами}.

В этом разделе рассматривается задача \textit{автоматической} генерации тестовых шаблонов для булевых схем (Automatic Test Pattern Generation \--- ATPG).
Сначала вводится понятие модели неисправностей (\textit{fault model}).
Затем формулируется задача генерации шаблонов (ATPG) для комбинационных схем (\textit{combinational circuits}).
Также упоминается последовательная (\textit{sequential}) постановка задачи ATPG для схем с элементами памяти, такими как триггеры (\textit{flip-flops}).
Наконец, кратко рассматриваются классические алгоритмы ATPG, работающие на структуре схемы.
% Представление оставлено кратким, для дальнейшего чтения мы ссылаемся на [JG03].
В~разделе~\ref{sub:sat-atpg} отдельно рассматриваются методы решения задачи ATPG, основанные на сведении к задаче выполнимости (SAT), как наиболее релевантные к текущей работе.

% 27.4.1.1. Модель неисправности Stuck-At
\subsubsection{Модель неисправности Stuck-At}

% TODO: refer to the section with circuit definition (note: check consistency)
Определение схемы было формально введено в начале этой главы.
Для упрощения чтения мы предполагаем, что схемы состоят только из элементов типа и, или, исключающего или и не (см. рисунок 27.6). Расширение этой библиотеки до других булевых элементов, если это необходимо, тривиально. Снова обратите внимание, что для элементов, представляющих несимметричные функции (например, мультиплексоры или элементы с тремя состояниями), уникальный порядок для входов задается порядком предшественников элемента.

После производства чипа необходимо проверить его функциональную корректность относительно спецификации схемы на уровне булевых элементов. Без этой проверки некорректный чип будет доставлен заказчикам, что может привести к неполадкам в конечном продукте. Это, конечно же, недопустимо. С другой стороны, из-за дефектов материала, вариаций процесса во время производства и т. д. возможен широкий диапазон неисправностей. Но непосредственная проверка всех возможных физических дефектов невозможна. Поэтому вводится абстракция в виде модели неисправности. Модель неисправности Stuck-At (SAFM) [BF76] хорошо известна и широко используется на практике. В этой модели неисправности предполагается, что одна линия застряла на фиксированном значении вместо зависимости от значений входов. Когда линия застряла на значении 0, это называется неисправностью stuck-at-0 (SA0). Аналогично, если линия застряла на значении 1, это называется неисправностью stuck-at-1 (SA1).

% TODO: \begin{example}
\textbf{Пример.}
Рассмотрим схему, показанную на рисунке 27.7(a). Когда на линии d вводится неисправность SA0, получается неисправная схема, показанная на рисунке 27.7(b). Выход элемента И отключается, и вход элемента ИЛИ постоянно принимает значение 0.

Помимо SAFM было предложено ряд других моделей неисправностей, например, клеточная модель неисправностей [Fri73], где меняется функция одного элемента, или модель мостовой неисправности [KP80], где предполагается, что две линии устанавливаются в одно значение. Эти модели неисправностей в основном охватывают статические физические дефекты, такие как обрывы или замыкания. Динамические эффекты охватываются моделями неисправностей задержки. В модели неисправности по задержке пути [Smi85] одна неисправность означает, что изменение значения вдоль пути от входов к выходам в схеме не приходит в течение времени цикла тактового сигнала. Вместо путей модель неисправности задержки на входах элементов [HRVD77, SB77] учитывает задержку в элементах.

Далее рассматривается только SAFM из-за его высокой значимости в практических применениях. Эту значимость можно объяснить двумя наблюдениями: количество неисправностей имеет порядок размера схемы, и моделирование неисправностей в SAFM относительно просто, то есть для статической модели неисправностей вычислительная сложность генерации тестовых шаблонов ниже по сравнению с динамическими моделями неисправностей.

% 27.4.1.2. Комбинационный ATPG
\subsubsection{Комбинационный ATPG}

Автоматическая генерация тестовых шаблонов (ATPG) - это задача вычисления набора тестовых шаблонов для заданной схемы с учетом модели неисправностей. Тестовый шаблон для конкретной неисправности - это назначение на основные входы схемы, которое приводит к различным выходным значениям в зависимости от наличия неисправности. Вычисление булевой разности между бездефектной и неисправной схемами дает все тестовые шаблоны для конкретной неисправности. Эта конструкция аналогична схеме Miter [Bra83], поскольку ее можно использовать для проверки эквивалентности комбинационной схемы.

% TODO: \begin{example}
\textbf{Пример.}
Снова рассмотрим неисправность SA0 в схеме на рисунке 27.7. Назначение входов a = 1, b = 1, c = 1 приводит к значению выхода f = 1 для корректной схемы и к значению выхода f = 0 в случае наличия неисправности. Поэтому это назначение входов является тестовым шаблоном для неисправности SA0 на линии d. Конструкция для вычисления булевой разности бездефектной и неисправной схем показана на рисунке 27.8.

Когда тестовый шаблон существует для конкретной неисправности, эта неисправность классифицируется как \textbf{тестируемая} (\textit{testable}).
Если тестовый шаблон отсутствует, неисправность называется \textit{избыточной} (\textit{redundant}).
Проблема классификации неисправности как тестируемой или избыточной является NP-полной.
Задача ATPG заключается в классификации всех неисправностей и создании набора тестовых шаблонов, содержащего хотя бы один тестовый шаблон для каждой испытуемой неисправности.

Генерация тестовых шаблонов для схем, содержащих элементы состояния (памяти), такие как триггеры (\textit{flip-flops}), вычислительно более сложна, потому что элементы памяти не могут быть непосредственно установлены в определенное значение.
Вместо этого поведение схемы во времени должно рассматриваться во время ATPG.
Было предложено ряд инструментов, которые непосредственно решают эту последовательную проблему, например, HITEC [NP91].
Но на практике получаемая модель часто слишком сложна для обработки с помощью инструментов ATPG.
Поэтому обычно рассматривается полный режим сканирования для преодоления этой проблемы путем подключения всех элементов состояния в цепочку сканирования [WA73, EW77].
В режиме тестирования цепочка сканирования объединяет все элементы состояния в сдвиговый регистр, в нормальном режиме работы элементы состояния управляются обычной логикой в схеме.
В результате элементы состояния могут рассматриваться как основные входы и выходы для тестирования, и получается комбинационная постановка задачи ATPG, уже рассмотренная выше.


\section{Задача булевой выполнимости}
\label{sec:sat}

Задача выполнимости булевых формул (Boolean satisfiability problem \--- SAT) формулируется следующим образом~\cite{handbook-sat}: для произвольной булевой формулы~$\phi(x_1, \dotsc, x_n)$ необходимо определить, существует ли подстановка значений переменных $X_\text{SAT}$, при которой формула становится истинной, то есть, формально, $\exists X_\text{SAT} \in \{0,1\}^n : \phi(X_\text{SAT}) = 1$.
Если такая подстановка существует, то она называется \textit{удовлетворяющей} (\textit{satisfying assignment}; также используются термины \textit{модель} и \textit{интерпретация}), а формула~$\phi$ называется \textit{выполнимой} (\textit{SATisfiable}).
В~противном случае, если удовлетворяющая подстановка не существует, $\phi$~называется \textit{невыполнимой} (\textit{UNSATisfiable}).

Задача SAT является первой задачей, для которой была доказана NP-полнота~\cite{cook}.
\todo{Описание универсальности задачи SAT}

% \subsection{Базовые определения}
% \label{sub:sat-definitions}

% \todo{Литерал, дизъюнкция, конъюнкция, КНФ, ДНФ}

Если булева формула $\phi$ представлена в конъюктивной нормальной форме (КНФ), то соответствующую задачу называют CNF-SAT.
Любая булева формула может быть преобразована в эквивалентную КНФ, однако при этом размер формулы может увеличиться экспоненциально, например:
\[
    \text{$n$ конъюнкций}
    \left\{
    \begin{aligned}
        & (x_1 \land y_1) \lor \\
        & (x_2 \land y_2) \lor \\
        & ~\dots \\
        & (x_n \land y_n)
    \end{aligned}
    \right.
    \quad
    \xRightarrow{\text{КНФ~}}
    \quad
    \left.
    \begin{aligned}
        & (x_1 \lor x_2 \lor \dotsb \lor x_n) \land \\
        & (y_1 \lor x_2 \lor \dotsb \lor x_n) \land \\
        & ~\dotsb \\
        & (y_1 \lor y_2 \lor \dotsb \lor y_n)
    \end{aligned}
    \right\}
    \text{$2^n$ дизъюнкций}
\]
С помощью преобразований Цейтина~\cite{tseitin1970} возможно привести любую булеву формулу в КНФ \--- с сохранением выполнимости (\textit{equisatisfiable CNF}), но с добавлением новых переменных (\textit{auxiliary variable}) \--- при этом размер формулы увеличится лишь линейно.
В данной работе подразумевается, что все булевы выражения, кодирующие задаваемые ограничения, подвергаются либо эквивалентным логическим преобразованиям, либо преобразованиям Цейтина, то есть по итогу представляются в виде КНФ.

\subsection{Алгоритм DPLL}
\label{sub:dpll}

\todo{Описание алгоритма DPLL}

\subsection{Алгоритм CDCL}
\label{sub:cdcl}

Conflict-Driven Clause Learning (CDCL) \--- это расширение классического алгоритма DPLL, включающее в себя механизмы анализа конфликтов и вывода новых дизъюнктов.
Алгоритм CDCL лежит в основе многих современных SAT-решателей благодаря своей эффективности при решении экземпляров задачи SAT.
Ниже приводится подробное описание алгоритма CDCL, а также псевдокод для наглядности.

\todo{Описание алгоритма CDCL}

\begin{algorithm}[H]
    \caption{DPLL Algorithm with Conflict Analysis and Clause Learning}
    \DontPrintSemicolon
    \SetKwInput{Input}{Input}
    \SetKwInput{Output}{Output}
    \SetKwFunction{AnalyzeConflict}{AnalyzeConflict}

    \Input{Boolean formula $F$, current assignment $\sigma$}
    \Output{satisfying assignment or indication of unsatisfiability}

    \While{not all variables assigned}{
        Branch on unassigned variable $v$ \;
        \eIf{$F$ becomes unsatisfiable under $\sigma \union \{v\}$}{
            $\beta \gets \AnalyzeConflict{$F, \sigma, v$}$ \;
            $F \gets F \union \{\beta\}$ \;
            Backtrack to previous decision level \;
        }{
            Continue recursive exploration \;
        }
    }
\end{algorithm}

\subsection{SAT-решатели}
\label{sub:sat-solvers}

На практике для решения задачи SAT используются специализированные программные средства \--- SAT-\emph{решатели}.
Несмотря на то, что задача SAT имеет экспоненциальную оценку сложности (при условии, что $P \neq NP$), современные SAT-решатели способны решать формулы с миллионами переменных за обозримое время.
Для выбора наиболее эффективного SAT-решателя можно руководствоваться результатами соревнования SAT~Comptetition~\cite{sat-competition}: среди текущих лидеров можно выделить MapleCOMSPS~\cite{liang-2016}, Cadical~\cite{cadical}, CryptoMiniSat~\cite{cryptominisat}, Glucose~\cite{glucose} и Plingeling~\cite{lingeling-and-friends}, хотя на практике эффективность решателей может значительно отличаться, в зависимости от класса рассматриваемых задач.
В некоторых случаях хорошие результаты также показывает MiniSat~\cite{minisat}, являющийся минимальной реализацией CDCL-решателя (\textit{Conflict-Driven Clause Learning}~\cite{grasp}) и служащий основой для многих других решателей (например, CryptoMiniSat и Glucose).

\todo{Инкрементальность}

\subsection{Методы сведения задач к SAT}
\label{sub:sat-encodings}

\todo{Пример сведения задачи раскраски графа к SAT -- описание переменных и ограничений. Дополнительно -- оптимизационная постановка задачи.}

\todo{LEC as SAT}

\todo{ATPG as SAT}

\subsection{Декомпозиционная трудность}
\label{sub:dhardness}

Концепция \textit{лазеек} (\textit{backdoors}) была введена в классической работе~\cite{williams2003}.
В частности, множество переменных~$B$ в произвольной КНФ-формуле~$C$ является \emph{сильной лазейкой} (Strong Backdoor Set \--- SBS) для~$C$ относительно некоторого полиномиального алгоритма~$P$ (называемого вспомогательным решателем (\textit{subsolver})), если формула~$C[\beta/B]$ решается с помощью~$P$ (то есть получается ответ SAT/UNSAT за полиномиальное время) для любого~$\beta \in \{0,1\}^{|B|}$.
Здесь через~$C[\beta/B]$ обозначается формула, полученная подстановкой значений~$\beta$ в переменные из~$B$ в~$C$.
Можно заметить~\cite{ansotegui2008}, что если $B$ \=== некоторый SBS, то сложность~$C$ ограничена сверху значением $\fun{poly}(|C|) \cdot 2^{|B|}$, где $\fun{poly}({\cdot})$ \=== некоторый полином.

В статье~\cite{semenov2021} было предложено использовать полный детерминированный SAT-решатель~$A$ в качестве вспомогательного решателя, вместо традиционного полиномиального алгоритма~$P$.
Для оценки производительности решателя, введём следующие обозначения.
Пусть~$t_A(C)$ обозначает время работы~$A$ на КНФ-формуле~$C$.
Сложность формулы~$C$ относительно множества~$B$ и солвера~$A$ может быть определена следующим образом:
\begin{equation}\label{eq:dhardness}
    \mu_{A,B}(C) = \bigsumclap{\beta \in \{0,1\}^{|B|}} t_A(C[\beta/B])
\end{equation}
Минимальное значение~\eqref{eq:dhardness} по всем возможным множествам~$B \in 2^X$ называется \textit{декомпозиционной трудностью} (\textit{decomposition hardness}) формулы~$C$ относительно алгоритма~$A$.

Как показано в~\cite{semenov2021}, значение~\eqref{eq:dhardness} можно выразить с использованием математического ожидания случайной величины~$\xi_B$, связанной с множеством~$B$, которая задается следующим соотношением:
\begin{equation}\label{eq:dh_mc}
    \mu_{A,B}(C) = 2^{|B|} \cdot \E[\xi_B]
\end{equation}
Для оценки значения~\eqref{eq:dhardness} можно использовать метод Монте-Карло и формулу~\eqref{eq:cheb}.
Это сводит задачу оценки сложности декомпозиции к задаче псевдо-булевой \textit{black-box} оптимизации, которая включает перебор различных множеств~$B$ и оценку сложности~$C$ относительно каждого~$B$ в попытке минимизировать это значение в пространстве~$2^X$.
В~\cite{semenov2021} для этой цели использовались метаэвристические алгоритмы.

\subsection{Вероятностные лазейки}
\label{sub:rho-backdoors}

\todo{$\rho$-backdoors}


\chapterconclusion

\todo{Завершение обзора}
